#!/usr/bin/env bash

#  fetchpack - A flexible cache cleaning utility in ChiliOS
#  Chili GNU/Linux - https://github.com/vcatafesta/ChiliOS
#  Chili GNU/Linux - https://chililinux.com
#  Chili GNU/Linux - https://chilios.com.br
#  MazonOS GNU/Linux - http://mazonos.com
#
#  Created: 2020/10/05
#  Altered: 2022/08/07
#
#  Copyright (c) 2019-2022, Vilmar Catafesta <vcatafesta@gmail.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#  fetchpack uses quite a few external programs during its execution. You
#  need to have at least the following installed for makepkg to function:
#     awk, bsdtar (libarchive), bzip2, coreutils, fakeroot, file, find (findutils),
#     gettext, gpg, grep, gzip, sed, tput (ncurses), xz
#########################################################################
export LC_ALL=C
export LANG=C
readonly DEPENDENCIES=(which find sed grep sort cat awk tput dialog)
declare -r myname='fetchpack'
declare -r myver='1.32.20220807'
declare -a cachedirs=()
declare -a candidates=() cmdopts=() candesc=()
declare -i delete=0 dryrun=0 move=0 totalsaved=0 pkgcount=0
declare -i verbose=0
declare -i ctime=0
declare -i QUIET=0
declare delim=$'\n'
declare keep=3
declare movedir=
declare USE_COLOR='y'
#readonly PKG_RE='(.+)-(([^-]+)-([0-9]))-([^.]+)(\.chi\.zst)'     #VC OLD
readonly PKG_RE='(.+)-(([^-]+)-([0-9])+)-([^.]+)(\.chi\.zst)' #VC
#readonly FETCH_RE='-[^-]+([0-9]+)-[0-9]+.'							   #VC
#readonly  FETCH_RE='-[^a-z]+?[^-]+-\d.*-'							  		#VC
#readonly FETCH_RE='-[^-]+[0-9]+-[^.]+-'										   #VC
#readonly FETCH_RE='-[^-]+-[0-9]-'										   #VC
#boareadonly  FETCH_RE='-[^-]+[0-9]+-([^.]+)[.]chi.*'							  		#VC
readonly FETCH_RE='-[^-]+[0-9]+-[^.]+.chi.*' #VC

# Expand to nothing if there are no matches
shopt -s nullglob
shopt -s extglob

# Import libs
LIBRARY=${LIBRARY:-'/usr/share/fetch'}
[ -e /etc/fetch/fetch.conf ] && source /etc/fetch/fetch.conf
[ -e "$LIBRARY/core.sh" ] && source "$LIBRARY/core.sh"
export PKG_EXT="${PKG_EXT:='chi.zst'}"

# flag's para split package
: "${aPKGSPLIT=()}"
: "${aPKGLIST=}"
: "${PKG_FOLDER_DIR=0}"
: "${PKG_FULLNAME=1}"
: "${PKG_ARCH=2}"
: "${PKG_BASE=3}"
: "${PKG_BASE_VERSION=4}"
: "${PKG_VERSION=5}"
: "${PKG_BUILD=6}"

sh_splitpkg() {
	file="$1"
	aPKGSPLIT=()

	pkg_folder_dir="${file%/*}" #remove arquivo deixando somente o diretorio/repo
	pkg_fullname="${file##*/}"  #remove diretorio deixando somente nome do pacote

	[[ "$pkg_folder_dir" == "$pkg_fullname" ]] && pkg_folder_dir="localhost"
	if [[ "$pkg_fullname" =~ $PKG_RE ]]; then
		pkg_fullname="${BASH_REMATCH[0]}"
		pkg_base="${BASH_REMATCH[1]}"
		pkg_version_build="${BASH_REMATCH[2]}"
		pkg_version="${BASH_REMATCH[3]}"
		pkg_build="${BASH_REMATCH[4]}"
		pkg_arch="${BASH_REMATCH[5]}"
		pkg_base_version="${pkg_base}-${pkg_version_build}"

		: <<'comment'
        debug " file            : $file\n" \
              "pkg_folder_dir  : $pkg_folder_dir\n" \
              "pkg_fullname    : $pkg_fullname\n" \
              "pkg_arch        : $pkg_arch\n" \
              "pkg_base        : $pkg_base\n" \
              "pkg_base_version: $pkg_base_version\n" \
              "pkg_version     : $pkg_version\n" \
              "pkg_build       : $pkg_build"
comment
		aPKGSPLIT=("$pkg_folder_dir"
			"$pkg_fullname"
			"$pkg_arch"
			"$pkg_base"
			"$pkg_base_version"
			"$pkg_version-$pkg_build"
			"$pkg_build"
		)
	fi
	return $?
}

#figlet
logo() {
	setvarcolors
	cat <<'EOF'
  __      _       _                      _
 / _| ___| |_ ___| |__  _ __   __ _  ___| | __  Copyright (C) 2019-2020 Vilmar Catafesta <vcatafesta@gmail.com>
| |_ / _ \ __/ __| '_ \| '_ \ / _` |/ __| |/ /
|  _|  __/ || (__| | | | |_) | (_| | (__|   <   Este programa pode ser redistribuído livremente
|_|  \___|\__\___|_| |_| .__/ \__,_|\___|_|\_\  sob os termos da Licença Pública Geral GNU.
                       |_|
EOF
	echo "$yellow"
	version
	echo "$reset"
}

version() {
	printf "%s %s\n" "$myname" "$myver"
	printf "%s\n" "Copyright (C) 2020 Vilmar Catafesta <vcatafesta@gmail.com>"
}

mainOLD() {
	local arr=
	local nfiles=
	local pkg=
	local AllFilesPackages=
	local pkg=
	local pkgInAll=
	local FilteredPackages=
	local AllFilteredPackages=

	for cachedir in "${cachedirs[@]}"; do
		[[ -d "$cachedir" ]] || die "cachedir '%s' does not exist or is not a directory" "$cachedir"
		if ((move || delete)); then
			[[ ! -w "$cachedir" ]] && needsroot=1
		fi
		pushd "$cachedir" &>/dev/null || die "failed to chdir to $cachedir"

		pkgInAll=
		FilteredPackages=
		AllFilesPackages=
		AllFilteredPackages=
		candidates=()
		candesc=()
		pkgNumber=0

		if [ $# -lt 1 ]; then
			AllFilesPackages=$(find "$PWD" -type f -iname "*.$PKG_EXT" | sort)
		else
			AllFilesPackages=$(find "$PWD" -type f -iname "*.$PKG_EXT" | grep "$1" | sort)
		fi

		arr=("${AllFilesPackages[*]}")
		nfiles=${#arr[*]}

		log_wait_msg "${reset}wait, searching ${red}($nfiles) ${reset}candidates for pruning in ${green}$cachedir"
		for pkgInAll in $AllFilesPackages; do
			((pkgNumber++))
			pkgInFullName="$pkgInAll"
			sh_splitpkg "$pkgInAll"
			FilteredPackages="${aPKGSPLIT[$PKG_BASE]}"
			AllFilteredPackages=$(find "$PWD" -type f -iname "$FilteredPackages*.zst" | grep -E "*$FilteredPackages-([0-9])" | sort)
			pkg=
			arr=("${AllFilteredPackages[*]}")
			array=("${AllFilteredPackages[*]}")
			nfiles=${#arr[*]}

			if ((verbose)); then
				printf "     ${white}verifying package ${purple}(%04d) ${green}[%40s]${purple}(%04d)${green} => %s\n" "$pkgNumber" "$FilteredPackages" "$nfiles" "${pkgInFullName}"
			fi

			if [[ nfiles -gt 1 ]]; then
				while read -r pkg; do
					sh_splitpkg "$pkg"
					SearchPkg="${aPKGSPLIT[$PKG_BASE]}"

					first="${FilteredPackages:1:1}"
					last="${SearchPkg:1:1}"

					if [[ $last > $first ]]; then
						break
					fi

					if [[ "$FilteredPackages" =~ $SearchPkg ]]; then
						if [[ $(vercmp "$pkgInFullName" "$pkg") -lt 0 ]]; then
							candidates+=("$pkgInFullName")
							canddesc+=("$pkgInFullName.desc")
							canddesc+=("$pkgInFullName.sha256")
							if ((verbose >= 3)); then
								[[ "$pkg" =~ $PKG_RE ]] && name="${BASH_REMATCH[1]}" arch="${BASH_REMATCH[2]}"
								if [[ -z "$seen" || "$seenarch" != "$arch" || "$seen" != "$name" ]]; then
									seen="$name"
									seenarch="$arch"
									printf '%s (%s):\n' "${name##*/}" "$arch"
								fi
								printf '  %s\n' "${pkg##*/}"
							elif ((verbose >= 2)); then
								printf "%s$delim" "$pkg"
							fi
						fi
					fi
				done < <(printf '%s\n' "${array[*]}")
			fi
		done
		popd >/dev/null 2>&1
	done

	if ((!${#candidates[*]})); then
		die "Process $nfiles: NO candidates packages found for pruning"
	fi

	pkgcount=${#candidates[*]}
	totalsaved=$(printf '%s\0' "${candidates[@]}" | xargs -0 stat -c %s | awk '{ sum += $1 } END { print sum }')
	set -o errexit # Exit immediately if a pipeline returns non-zero.

	((verbose)) && cmdopts+=(-v)
	cmdopts+=(-f)
	if ((delete)); then
		printf '%s\0' "${candidates[@]}" | runcmd xargs -0 rm "${cmdopts[@]}"
		printf '%s\0' "${canddesc[@]}" | runcmd xargs -0 rm "${cmdopts[@]}"
	elif ((move)); then
		printf '%s\0' "${candidates[@]}" | runcmd xargs -0 mv "${cmdopts[@]}" -t "$movedir"
	fi
	echo
	msg "$output (disk space saved: %s)" "$(size_to_human "$totalsaved")"
}

cleanup() {
	msg "Exiting.."
	exit
}
trap cleanup SIGINT SIGTERM

main() {
	local nfiles=0
	local pkg=
	local pkgInAll=
	local pkg_base=
	local candidates=()
	local cachedir
	local re="$FETCH_RE"

	if ((QUIET)); then
		verbose=0
	else
		if ((verbose)); then
			if ((dryrun)); then
				log_msg "${white}running mode => ${green}DRY-RUN"
			elif ((delete)); then
				log_msg "${white}running mode => ${red}DELETE"
			elif ((move)); then
				log_msg "${white}running mode => ${yellow}MOVE"
			fi
		fi
	fi

	for cachedir in "${cachedirs[@]}"; do
		[[ -d $cachedir ]] || {
			log_failure_msg2 "${red}Error: cachedir '$cachedir' does not exist or is not a directory -- skipping"
			continue
		}
		pushd "$cachedir" &>/dev/null || die "Error: failed to chdir to $cachedir"

		if [ $# -lt 1 ]; then
			AllOldPackages=$(find "$PWD" -type f -iname "*.$PKG_EXT" | sort -Vr | awk -F "$re" 'lista[$1]++')
		else
			AllOldPackages=$(find "$PWD" -type f -iname "*.$PKG_EXT" | grep "$1" | sort -Vr | awk -F "$re" 'lista[$1]++')
		fi

		while read -r pkgInAll; do
			pkg_base="$pkgInAll"
			[[ -z "$pkg_base" ]] && continue
			((++pkgNumber))

			if ((verbose >= 3)); then
				printf "  $(DOT)${white}candidate package ${purple}(%04d) ${green}%s\n" "$pkgNumber" "$pkg_base"
			fi
			[[ -e "$pkgInAll" ]] && candidates+=("$pkgInAll")
			[[ -e "$pkgInAll.desc" ]] && candesc+=("$pkgInAll.desc")
		done <<<"$AllOldPackages" #done < <(printf '%s\n' "$AllOldPackages") #done <<< $(printf '%s\n' "$AllOldPackages")
		popd >/dev/null 2>&1
	done

	if ((!${#candidates[*]})); then
		log_msg "${green}NO candidates packages found for pruning"
		exit
	fi

	if ((verbose >= 2)); then
		pkgNumber=0
		while read -r pkg; do
			((++pkgNumber))
			printf "  $(DOT)${white}found package ${purple}(%04d) ${green}%42s\n" "$pkgNumber" "$pkg"
		done <<<"$(printf '%s\n' "${candidates[@]}")"
		#done < <(printf '%s\n' "${candidates[@]}") #done <<< "${candidates[@]}"
	fi

	ncandidates=${#candidates[*]}
	ncandesc=${#candesc[*]}
	pkgcount=$((ncandidates + ncandesc))

	((ncandidates)) && totalsaved=$(printf '%s\0' "${candidates[@]}" | xargs -0 stat -c %s | awk '{ sum += $1 } END { print sum }')
	((ncandesc)) && totalsaved+=$(printf '%s\0' "${candesc[@]}" | xargs -0 stat -c %s | awk '{ sum += $1 } END { print sum }')
	set -o errexit # Exit immediately if a pipeline returns non-zero.

	if ((delete)); then
		((verbose)) && cmdopts+=(-v)
		cmdopts+=(-f)
		((ncandidates)) && printf '%s\0' "${candidates[@]}" | runcmd xargs -0 rm "${cmdopts[@]}"
		((ncandesc)) && printf '%s\0' "${candesc[@]}" | runcmd xargs -0 rm "${cmdopts[@]}"
	elif ((move)); then
		((verbose)) && cmdopts+=(-v)
		cmdopts+=(-f)
		((ncandidates)) && printf '%s\0' "${candidates[@]}" | runcmd xargs -0 mv "${cmdopts[@]}" -t "$movedir"
		((ncandesc)) && printf '%s\0' "${candesc[@]}" | runcmd xargs -0 mv "${cmdopts[@]}" -t "$movedir"
	elif ((verbose)); then
		((ncandidates)) && printf '%s\0' "${candidates[@]}" | xargs -0 printf "  $(DOT)%s\n" "${cmdopts[@]}"
		((ncandesc)) && printf '%s\0' "${candesc[@]}" | xargs -0 printf "  $(DOT)%s\n" "${cmdopts[@]}"
	fi

	if ((!QUIET)); then
		if ((dryrun)); then
			msg "${yellow}$output finish dry-run (packages found: $ncandidates with .desc) (disk space saved: %s)" "$(size_to_human "$totalsaved")"
		else
			msg "$output (packages found: $ncandidates with .desc) (disk space saved: %s)" "$(size_to_human "$totalsaved")"
		fi
	fi
	return 0
}

usage() {
	cat <<EOF
${cyan}Usage: ${yellow}fetch -Sc <operation> [options] [targets...]${reset}

  Operations:
${red}     -d, --dryrun          ${reset}perform a dry run, only finding candidate packages.
${red}     -m, --move <dir>      ${reset}move candidate packages to "dir".
${red}     -r, --remove          ${reset}remove candidate packages.

  Options:
${red}     -c, --cachedir <dir>  ${reset}scan "dir" for packages. can be used more than once.
                           (default: read from /etc/fetch/fetch.conf).
${red}     -k, --keep <num>      ${reset}keep "num" of each package in the cache (default: 1).
${red}     -f, --force           ${reset}apply force to mv(1) and rm(1) operations.
${red}     -h, --help            ${reset}display this help message and exit.
${red}         --nocolor         ${reset}remove color from output.
${red}     -q, --quiet           ${reset}quiet output.
${red}     -v, --verbose         ${reset}increase verbosity. specify up to 3 times ([-v][-vv][-vvv]).

${cyan}most common use: ${yellow}fetch -Sc -k1 -r -v${reset}
EOF
}

sh_checkroot
checkDependencies

OPT_SHORT=':a:c:dfhi:k:m:qrsuVvzt:'
OPT_LONG=('arch:' 'cachedir:' 'dryrun' 'force' 'help' 'ignore:' 'keep:' 'move:' 'nocolor' 'quiet' 'remove' 'uninstalled' 'version' 'verbose' 'null' 'ctime:')

if ! parseopts "$OPT_SHORT" "${OPT_LONG[@]}" -- "$@"; then
	exit 1
fi
set -- "${OPTRET[@]}"
unset OPT_SHORT OPT_LONG OPTRET

while :; do
	case $1 in
	-t | --ctime)
		ctime="$2"
		shift
		;;
	-c | --cachedir)
		cachedirs+=("$2")
		shift
		;;
	-d | --dryrun)
		dryrun=1
		;;
	-f | --force)
		cmdopts=(-f)
		;;
	-h | --help)
		usage
		exit 0
		;;
	-m | --move)
		move=1 movedir=$2
		shift
		;;
	--nocolor)
		unsetvarcolors
		USE_COLOR='n'
		;;
	-q | --quiet)
		unsetvarcolors
		QUIET=1
		;;
	-r | --remove)
		delete=1
		;;
	-V | --version)
		logo
		exit 0
		;;
	-v | --verbose)
		((++verbose))
		;;
	-z | --null)
		delim='\0'
		;;
	--)
		shift
		break 2
		;;
	esac
	shift
done

# check if messages are to be printed using color
if [[ -t 2 && $USE_COLOR != "n" ]]; then
	setvarcolors
fi

# setting default cachedirs
if [[ -z "${cachedirs[*]}" ]]; then
	cachedirs=("${GITDIR:=/var/cache/fetch/archives}")
	cachedirs+=("/var/cache/fetch/archives")
fi

# sanity checks
case $((dryrun + delete + move)) in
0) die "no operation specified (use -h for help)" ;;
[^1]) die "only one operation may be used at a time" ;;
esac

[[ $movedir && ! -d $movedir ]] && die "destination directory '$movedir' does not exist or is not a directory!"

if ((move || delete)); then
	# make it an absolute path since we're about to chdir
	[[ $movedir && ${movedir:0:1} != '/' ]] && movedir=$PWD/$movedir
	[[ $movedir && ! -w $movedir ]] && needsroot=1
fi

main "$@"
