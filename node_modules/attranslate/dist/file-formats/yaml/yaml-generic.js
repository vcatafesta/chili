"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.YamlGeneric = exports.isScalar = exports.isPair = exports.isCollection = exports.isSequence = void 0;
const yaml_1 = require("yaml");
const format_cache_1 = require("../common/format-cache");
const flatten_1 = require("../../util/flatten");
const types_1 = require("yaml/types");
const yaml_manipulation_1 = require("./yaml-manipulation");
const util_1 = require("yaml/util");
const yaml_parse_1 = require("./yaml-parse");
const managed_utf8_1 = require("../common/managed-utf8");
function isSequence(node) {
    if (!node.type) {
        return false;
    }
    return [util_1.Type.SEQ, util_1.Type.FLOW_SEQ].includes(node.type);
}
exports.isSequence = isSequence;
function isCollection(node) {
    if (!node) {
        return false;
    }
    if (!node.type) {
        return false;
    }
    return [
        util_1.Type.MAP,
        util_1.Type.FLOW_MAP,
        util_1.Type.SEQ,
        util_1.Type.FLOW_SEQ,
        util_1.Type.DOCUMENT,
    ].includes(node.type);
}
exports.isCollection = isCollection;
function isPair(node) {
    if (!node) {
        return false;
    }
    if (!node.type) {
        return false;
    }
    return [types_1.Pair.Type.PAIR, types_1.Pair.Type.MERGE_PAIR].includes(node.type);
}
exports.isPair = isPair;
function isScalar(node) {
    if (!node.type) {
        return false;
    }
    return [
        util_1.Type.BLOCK_FOLDED,
        util_1.Type.BLOCK_LITERAL,
        util_1.Type.PLAIN,
        util_1.Type.QUOTE_DOUBLE,
        util_1.Type.QUOTE_SINGLE,
    ].includes(node.type);
}
exports.isScalar = isScalar;
const documentCache = new format_cache_1.FormatCache();
class YamlGeneric {
    constructor() {
        // Do not mess with user's line breaks; preserve everything as is!
        yaml_1.scalarOptions.str.fold = { lineWidth: 0, minContentWidth: 0 };
        yaml_1.scalarOptions.str.doubleQuoted = {
            minMultiLineLength: 1000,
            jsonEncoding: false,
        };
        yaml_1.scalarOptions.null.nullStr = "";
    }
    readTFile(args) {
        const document = (0, yaml_parse_1.parseYaml)(args);
        if (!document) {
            return Promise.resolve(new Map());
        }
        documentCache.insertFileCache({
            path: args.path,
            entries: new Map(),
            auxData: document,
        });
        const tSet = (0, yaml_manipulation_1.extractYmlNodes)(args, document);
        return Promise.resolve(tSet);
    }
    writeTFile(args) {
        const sourceYml = documentCache.getOldestAuxdata();
        let ymlString;
        if (sourceYml) {
            ymlString = this.createCachedYml(args, sourceYml);
        }
        else {
            ymlString = this.createUncachedYml(args);
        }
        (0, managed_utf8_1.writeManagedUtf8)({ path: args.path, utf8: ymlString });
        documentCache.purge();
    }
    createCachedYml(args, sourceYml) {
        const oldTargetYml = documentCache.lookupSameFileAuxdata({
            path: args.path,
        });
        (0, yaml_manipulation_1.updateYmlNodes)({ args, sourceYml, oldTargetYml });
        return sourceYml.toString();
    }
    createUncachedYml(args) {
        const flatJson = {};
        args.tSet.forEach((value, key) => {
            flatJson[key] = value;
        });
        const nestedJson = (0, flatten_1.unflatten)(flatJson);
        const options = {
            mapAsMap: false,
        };
        return (0, yaml_1.stringify)(nestedJson, options);
    }
}
exports.YamlGeneric = YamlGeneric;
