"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseiOSFile = exports.VALUE_INDEX = void 0;
const parse_utils_1 = require("../common/parse-utils");
const managed_utf8_1 = require("../common/managed-utf8");
const KEY_INDEX = 1;
exports.VALUE_INDEX = 3;
function parseiOSFile(args) {
    const rawString = (0, managed_utf8_1.readManagedUtf8)(args.path);
    const lines = rawString.split("\n");
    if (!lines.length) {
        (0, parse_utils_1.logParseError)("Empty file", args);
    }
    const iosFile = {
        path: args.path,
        entries: new Map(),
        auxData: [],
    };
    let currentChunk = [];
    lines.forEach((line) => {
        const keyValue = parseiOSLine(args, line);
        currentChunk.push(line);
        if (keyValue) {
            const key = keyValue.key;
            const value = keyValue.value;
            const lineChunk = {
                value,
                lines: currentChunk,
            };
            if (iosFile.entries.has(key)) {
                (0, parse_utils_1.logParseError)(`duplicate key '${key}' -> Currently, the usage of duplicate translation-keys is discouraged.`, args);
            }
            iosFile.entries.set(key, lineChunk);
            currentChunk = [];
        }
    });
    if (!iosFile.entries.size) {
        (0, parse_utils_1.logParseError)("Did not find any Strings in the expected format", args);
    }
    return iosFile;
}
exports.parseiOSFile = parseiOSFile;
function parseiOSLine(args, line) {
    if (!line.trim().length) {
        return null;
    }
    if (isComment(line)) {
        return null;
    }
    const token = line.split('"');
    if (token.length < 5) {
        (0, parse_utils_1.logParseWarning)(`Line '${line}' seems to be unexpected`, args);
        return null;
    }
    const key = token[KEY_INDEX];
    if (!key || !key.trim().length) {
        (0, parse_utils_1.logParseWarning)(`Did not find a key in '${line}'`, args);
        return null;
    }
    const value = token[exports.VALUE_INDEX];
    return {
        key,
        value,
    };
}
function isComment(line) {
    const trimLine = line.trim();
    if (trimLine.startsWith("//")) {
        return true;
    }
    return trimLine.startsWith("/*") || trimLine.endsWith("*/");
}
