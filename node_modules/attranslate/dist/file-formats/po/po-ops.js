"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parsePotFile = exports.updatePotTranslations = exports.extractPotTranslations = void 0;
const gettext_parser_1 = require("gettext-parser");
const parse_utils_1 = require("../common/parse-utils");
const po_files_1 = require("./po-files");
function mergePotComments(args) {
    if (!args.source) {
        return args.oldTarget;
    }
    const source = args.source;
    const oldTarget = args.oldTarget;
    for (const key of Object.keys(source)) {
        const sourceValue = source[key];
        if (!oldTarget[key]) {
            oldTarget[key] = sourceValue;
        }
    }
    return args.oldTarget;
}
function extractPotTranslations(args, potFile) {
    const tSet = new Map();
    traversePot(potFile, (getText) => {
        const key = getText.msgid;
        const value = getText.msgstr.join();
        if (key) {
            tSet.set(key, value);
        }
        const comments = getText.comments;
        if (typeof key === "string" && comments) {
            po_files_1.potCache.insert({ path: args.path, key, entry: { comments } });
        }
    });
    return tSet;
}
exports.extractPotTranslations = extractPotTranslations;
function updatePotTranslations(args, potFile) {
    const oldTarget = po_files_1.potCache.lookupSameFileAuxdata({ path: args.path });
    if (oldTarget) {
        potFile.headers = oldTarget.potFile.headers;
    }
    traversePot(potFile, (getText) => {
        var _a, _b;
        const key = getText.msgid;
        const value = args.tSet.get(key);
        if (value !== undefined) {
            getText.msgstr = [value !== null && value !== void 0 ? value : ""];
        }
        const oldTargetComments = (_a = po_files_1.potCache.lookup({
            path: args.path,
            key,
        })) === null || _a === void 0 ? void 0 : _a.comments;
        if (typeof key === "string" && oldTargetComments) {
            getText.comments = mergePotComments({
                source: (_b = getText.comments) !== null && _b !== void 0 ? _b : null,
                oldTarget: oldTargetComments,
            });
        }
    });
}
exports.updatePotTranslations = updatePotTranslations;
function parsePotFile(args, rawFile) {
    try {
        const potFile = gettext_parser_1.po.parse(rawFile);
        if (!potFile.headers) {
            potFile.headers = {};
        }
        potFile.headers["X-Generator"] = "attranslate";
        return potFile;
    }
    catch (e) {
        console.error(e);
        (0, parse_utils_1.logParseError)("GetText parsing error", args);
    }
}
exports.parsePotFile = parsePotFile;
function traversePot(potFile, operation) {
    for (const outerKey of Object.keys(potFile.translations)) {
        const potEntry = potFile.translations[outerKey];
        for (const innerKey of Object.keys(potEntry)) {
            const getText = potEntry[innerKey];
            operation(getText);
        }
    }
}
