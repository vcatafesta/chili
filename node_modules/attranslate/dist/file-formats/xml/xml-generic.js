"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.XmlGeneric = exports.DEFAULT_XML_HEADER = exports.DEFAULT_XML_INDENT = exports.sharedXmlOptions = exports.defaultExcludedContentKey = exports.defaultKeyAttribute = void 0;
const xml_read_1 = require("./xml-read");
const format_cache_1 = require("../common/format-cache");
const xml_write_1 = require("./xml-write");
const managed_utf8_1 = require("../common/managed-utf8");
const xmlCache = new format_cache_1.FormatCache();
exports.defaultKeyAttribute = "name";
exports.defaultExcludedContentKey = "string";
exports.sharedXmlOptions = {
    attrkey: "attributesObj",
    charkey: "characterContent",
};
/**
 * Android Studio seems to auto-format XML-files with 4 spaces indentation.
 */
exports.DEFAULT_XML_INDENT = 4;
exports.DEFAULT_XML_HEADER = '<?xml version="1.0" encoding="utf-8"?>';
class XmlGeneric {
    async readTFile(args) {
        const xmlString = (0, managed_utf8_1.readManagedUtf8)(args.path);
        const xmlFile = await (0, xml_read_1.parseRawXML)(xmlString, args);
        if (!xmlFile) {
            return new Map();
        }
        const firstLine = (0, xml_read_1.extractFirstLine)(xmlString);
        const fileCache = {
            path: args.path,
            auxData: {
                xmlHeader: firstLine.includes("<?") ? firstLine : null,
                xmlFile,
                detectedIntent: (0, xml_read_1.detectSpaceIndent)(xmlString),
            },
            entries: new Map(),
        };
        xmlCache.insertFileCache(fileCache);
        return (0, xml_read_1.extractXmlContent)({ args, xmlFile });
    }
    writeTFile(args) {
        var _a;
        const sourceXml = (_a = xmlCache.getOldestAuxdata()) === null || _a === void 0 ? void 0 : _a.xmlFile;
        let resultXml;
        if (sourceXml) {
            resultXml = this.extractCachedXml(args, sourceXml);
        }
        else {
            resultXml = this.createUncachedXml(args);
        }
        (0, xml_write_1.writeXmlResourceFile)(resultXml, args, xmlCache.lookupAuxdata({ path: args.path }));
        xmlCache.purge();
    }
    extractCachedXml(args, sourceXml) {
        var _a, _b;
        const oldTargetXml = (_b = (_a = xmlCache.lookupSameFileAuxdata({
            path: args.path,
        })) === null || _a === void 0 ? void 0 : _a.xmlFile) !== null && _b !== void 0 ? _b : null;
        (0, xml_write_1.updateXmlContent)({ args, sourceXml, oldTargetXml });
        return sourceXml;
    }
    createUncachedXml(args) {
        const tagArray = [];
        args.tSet.forEach((value, key) => {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-ignore
            tagArray.push({
                characterContent: value !== null && value !== void 0 ? value : "",
                attributesObj: { name: key },
            });
        });
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        const rootTag = {
            string: tagArray,
        };
        return {
            resources: rootTag,
        };
    }
}
exports.XmlGeneric = XmlGeneric;
