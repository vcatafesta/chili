"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverseXml = exports.constructJsonKey = void 0;
const xml_generic_1 = require("./xml-generic");
const flatten_1 = require("../../util/flatten");
function constructJsonKey(context) {
    return context.keyFragments.join(flatten_1.NESTED_JSON_SEPARATOR);
}
exports.constructJsonKey = constructJsonKey;
function traverseXml(args) {
    var _a;
    const context = {
        keyFragments: [],
        operation: args.operation,
    };
    for (const contentKey of Object.keys(args.xml)) {
        const xmlContent = args.xml[contentKey];
        const oldTargetTag = args.oldTargetXml
            ? (_a = args.oldTargetXml[contentKey]) !== null && _a !== void 0 ? _a : null
            : null;
        if (typeof xmlContent === "object") {
            traverseRecursive({
                context,
                tag: xmlContent,
                oldTargetTag,
            });
        }
    }
}
exports.traverseXml = traverseXml;
function traverseRecursive(args) {
    if (typeof args.tag !== "object") {
        return;
    }
    if (typeof args.oldTargetTag !== typeof args.tag) {
        args.oldTargetTag = null;
    }
    else if (args.oldTargetTag && typeof args.oldTargetTag === "object") {
        if (typeof args.oldTargetTag.attributesObj === "object") {
            args.tag.attributesObj = {
                ...args.tag.attributesObj,
                ...args.oldTargetTag.attributesObj,
            };
        }
        if (isNonEmptyArray(args.oldTargetTag.comments)) {
            args.tag.comments = args.oldTargetTag.comments;
        }
    }
    let hasChildTags = false;
    for (const contentKey of Object.keys(args.tag)) {
        const xmlContent = args.tag[contentKey];
        if (contentKey !== "comments" && isNonEmptyArray(xmlContent)) {
            hasChildTags = true;
            const oldTargetChilds = extractOldTargetChilds(args.oldTargetTag, contentKey);
            xmlContent.forEach((sourceChild, index) => {
                const newKeyFragments = constructKeyFragments({
                    tag: sourceChild,
                    contentKey,
                    index,
                });
                const newContext = {
                    keyFragments: [...args.context.keyFragments, ...newKeyFragments],
                    operation: args.context.operation,
                };
                if (typeof sourceChild === "string") {
                    const newContent = args.context.operation(newContext, sourceChild);
                    if (newContent !== null) {
                        xmlContent[index] = newContent;
                    }
                }
                else {
                    traverseRecursive({
                        context: newContext,
                        tag: sourceChild,
                        oldTargetTag: matchOldTargetChild({
                            oldTargetChilds,
                            sourceChild,
                            index,
                        }),
                    });
                }
            });
        }
    }
    if (!hasChildTags) {
        const newContent = args.context.operation(args.context, args.tag);
        if (newContent !== null) {
            args.tag.characterContent = newContent;
        }
    }
}
function extractAttributeKey(tag) {
    var _a;
    if (typeof tag !== "object") {
        return null;
    }
    const attributes = tag.attributesObj;
    if (!attributes || typeof attributes !== "object") {
        return null;
    }
    return (_a = attributes[xml_generic_1.defaultKeyAttribute]) !== null && _a !== void 0 ? _a : null;
}
function constructKeyFragments(args) {
    const keyFragments = [];
    const attributeKey = extractAttributeKey(args.tag);
    if (attributeKey) {
        if (args.contentKey !== xml_generic_1.defaultExcludedContentKey) {
            keyFragments.push(args.contentKey);
        }
        keyFragments.push(attributeKey);
    }
    else {
        keyFragments.push(args.contentKey + "_" + args.index);
    }
    return keyFragments;
}
function extractOldTargetChilds(oldTargetXml, contentKey) {
    if (!oldTargetXml) {
        return null;
    }
    if (typeof oldTargetXml !== "object") {
        return null;
    }
    const xmlContent = oldTargetXml[contentKey];
    if (xmlContent && typeof xmlContent === "object") {
        return xmlContent;
    }
    return null;
}
function matchOldTargetChild(args) {
    var _a;
    if (!isNonEmptyArray(args.oldTargetChilds)) {
        return null;
    }
    const sourceAttributeKey = extractAttributeKey(args.sourceChild);
    if (sourceAttributeKey) {
        return ((_a = args.oldTargetChilds.find((oldTargetChild) => {
            const oldTargetAttributeKey = extractAttributeKey(oldTargetChild);
            return (oldTargetAttributeKey && oldTargetAttributeKey === sourceAttributeKey);
        })) !== null && _a !== void 0 ? _a : null);
    }
    else if (args.oldTargetChilds.length > args.index) {
        return args.oldTargetChilds[args.index];
    }
    else {
        return null;
    }
}
function isNonEmptyArray(obj) {
    if (!obj) {
        return false;
    }
    if (!Array.isArray(obj)) {
        return false;
    }
    if (!obj.length) {
        return false;
    }
    return true;
}
