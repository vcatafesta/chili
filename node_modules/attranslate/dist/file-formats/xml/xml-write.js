"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeXmlResourceFile = exports.updateXmlContent = void 0;
const xml_generic_1 = require("./xml-generic");
const xml_traverse_1 = require("./xml-traverse");
const managed_utf8_1 = require("../common/managed-utf8");
function updateXmlContent(args) {
    (0, xml_traverse_1.traverseXml)({
        xml: args.sourceXml,
        oldTargetXml: args.oldTargetXml,
        operation: (context, xmlTag) => {
            const key = (0, xml_traverse_1.constructJsonKey)(context);
            const value = args.args.tSet.get(key);
            if (value !== undefined) {
                return value !== null && value !== void 0 ? value : "";
            }
            return null;
        },
    });
}
exports.updateXmlContent = updateXmlContent;
function writeXmlResourceFile(xmlFile, args, auxData) {
    var _a;
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const xml2js = require("xml2js");
    const stringIndent = " ".repeat((_a = auxData === null || auxData === void 0 ? void 0 : auxData.detectedIntent) !== null && _a !== void 0 ? _a : xml_generic_1.DEFAULT_XML_INDENT);
    const options = {
        ...xml_generic_1.sharedXmlOptions,
        headless: true,
        renderOpts: {
            pretty: true,
            indent: stringIndent,
        },
    };
    // See https://github.com/oozcitak/xmlbuilder-js/wiki/Builder-Options for available xmlBuilderOptions
    const xmlBuilderOptions = {
        noValidation: false,
        noDoubleEncoding: true,
    };
    const mergedOptions = { ...options, xmlBuilderOptions };
    const builder = new xml2js.Builder(mergedOptions);
    const rawXmlString = builder.buildObject(xmlFile);
    let xmlHeader = xml_generic_1.DEFAULT_XML_HEADER + "\n";
    if (auxData) {
        if (auxData.xmlHeader) {
            xmlHeader = auxData.xmlHeader + "\n";
        }
        else {
            xmlHeader = "";
        }
    }
    const xmlString = `${xmlHeader}${removeBlankLines(rawXmlString)}\n`;
    (0, managed_utf8_1.writeManagedUtf8)({ path: args.path, utf8: xmlString });
}
exports.writeXmlResourceFile = writeXmlResourceFile;
function removeBlankLines(str) {
    const lines = str.split("\n");
    const filteredLines = lines.filter((line) => {
        return line.trim().length >= 1;
    });
    return filteredLines.join("\n");
}
