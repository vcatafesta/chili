"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.areEqual = exports.leftMinusRight = exports.joinResultsPreserveOrder = exports.selectLeftDistinct = void 0;
const core_util_1 = require("./core-util");
function selectLeftDistinct(left, right, strategy) {
    const leftDistinct = new Map();
    left.forEach((leftValue, key) => {
        const rightValue = right.get(key);
        const distinct = compareLeftRight({ leftValue, rightValue, strategy });
        if (distinct) {
            leftDistinct.set(key, leftValue);
        }
    });
    return leftDistinct;
}
exports.selectLeftDistinct = selectLeftDistinct;
function compareLeftRight(args) {
    switch (args.strategy) {
        case "COMPARE_KEYS":
            return args.rightValue === undefined;
        case "COMPARE_KEYS_AND_NULL_VALUES":
            return (args.rightValue === undefined ||
                (args.rightValue === null && args.leftValue !== null));
        case "COMPARE_VALUES":
            return (args.rightValue !== undefined && args.leftValue !== args.rightValue);
    }
}
function joinResultsPreserveOrder(args) {
    // To prevent file-scrambling, we have to preserve the order of the old target.
    const targetOrder = [];
    args.oldTarget.forEach((value, key) => {
        targetOrder.push(key);
    });
    // Newly added translations are more flexible in its position.
    // Therefore, we try to mimic the order of src.
    injectNewKeysIntoTargetOrder({
        targetOrder,
        newlyAdded: args.changeSet.added,
        oldTarget: args.oldTarget,
        src: args.src,
    });
    // Create an in-order map out of the determined targetOrder
    const joinResult = new Map();
    targetOrder.forEach((key) => {
        const freshResult = args.translateResults.get(key);
        const oldResult = args.oldTarget.get(key);
        if (freshResult !== undefined) {
            joinResult.set(key, freshResult);
        }
        else if (oldResult !== undefined) {
            joinResult.set(key, oldResult);
        }
    });
    // Add any remaining newly added translations whose target order was not determined.
    args.changeSet.added.forEach((value, key) => {
        if (!joinResult.has(key)) {
            joinResult.set(key, value);
        }
    });
    return joinResult;
}
exports.joinResultsPreserveOrder = joinResultsPreserveOrder;
function injectNewKeysIntoTargetOrder(args) {
    let injectPosition = 0;
    args.src.forEach((srcValue, srcKey) => {
        if (args.oldTarget.get(srcKey) !== undefined) {
            injectPosition =
                1 +
                    (0, core_util_1.getElementPosition)({
                        array: args.targetOrder,
                        element: srcKey,
                    });
        }
        if (args.newlyAdded.get(srcKey) !== undefined) {
            (0, core_util_1.insertAt)(args.targetOrder, injectPosition, srcKey);
            injectPosition++;
        }
    });
}
function leftMinusRight(left, right) {
    const leftRemaining = new Map();
    left.forEach((value, key) => {
        if (!right.has(key)) {
            leftRemaining.set(key, value);
        }
    });
    return leftRemaining;
}
exports.leftMinusRight = leftMinusRight;
function areEqual(set1, set2) {
    if (set1.size !== set2.size) {
        return false;
    }
    for (const key1 of set1.keys()) {
        const value1 = set1.get(key1);
        const value2 = set2.get(key1);
        if (value1 !== value2) {
            return false;
        }
    }
    for (const key2 of set2.keys()) {
        const value1 = set1.get(key2);
        const value2 = set2.get(key2);
        if (value1 !== value2) {
            return false;
        }
    }
    return true;
}
exports.areEqual = areEqual;
