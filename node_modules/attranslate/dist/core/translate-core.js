"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateCore = void 0;
const tset_ops_1 = require("./tset-ops");
const core_util_1 = require("./core-util");
const util_1 = require("../util/util");
const invoke_translation_service_1 = require("./invoke-translation-service");
function extractStringsToTranslate(args) {
    const src = args.src;
    if (!src.size) {
        (0, util_1.logFatal)("Did not find any source translations");
    }
    const oldTarget = args.oldTarget;
    if (!oldTarget) {
        // Translate everything if an old target does not yet exist.
        return src;
    }
    else {
        // Translate values whose keys are not in the target.
        return (0, tset_ops_1.selectLeftDistinct)(src, oldTarget, "COMPARE_KEYS_AND_NULL_VALUES");
    }
}
function extractStaleTranslations(args) {
    if (args.oldTarget) {
        return (0, tset_ops_1.leftMinusRight)(args.oldTarget, args.src);
    }
    else {
        return null;
    }
}
function computeChangeSet(args, serviceInvocation) {
    const deleted = extractStaleTranslations(args);
    if (!serviceInvocation) {
        return {
            added: new Map(),
            updated: new Map(),
            skipped: new Map(),
            deleted,
        };
    }
    const skipped = (0, tset_ops_1.selectLeftDistinct)(serviceInvocation.inputs, serviceInvocation.results, "COMPARE_KEYS");
    if (!args.oldTarget) {
        return {
            added: serviceInvocation.results,
            updated: new Map(),
            skipped,
            deleted,
        };
    }
    const added = (0, tset_ops_1.selectLeftDistinct)(serviceInvocation.results, args.oldTarget, "COMPARE_KEYS");
    const updated = (0, tset_ops_1.selectLeftDistinct)(serviceInvocation.results, args.oldTarget, "COMPARE_VALUES");
    return {
        added,
        updated,
        skipped,
        deleted,
    };
}
function computeNewTarget(args, changeSet, serviceInvocation) {
    const oldTargetRef = args.oldTarget && changeSet.deleted
        ? (0, tset_ops_1.leftMinusRight)(args.oldTarget, changeSet.deleted)
        : args.oldTarget;
    if (!serviceInvocation) {
        return oldTargetRef !== null && oldTargetRef !== void 0 ? oldTargetRef : new Map();
    }
    if (!oldTargetRef) {
        return serviceInvocation.results;
    }
    return (0, tset_ops_1.joinResultsPreserveOrder)({
        translateResults: serviceInvocation.results,
        changeSet,
        oldTarget: oldTargetRef,
        src: args.src,
    });
}
function computeCoreResults(args, serviceInvocation, changeSet) {
    return {
        changeSet,
        serviceInvocation,
        newTarget: computeNewTarget(args, changeSet, serviceInvocation),
    };
}
async function translateCore(args) {
    const serviceInputs = extractStringsToTranslate(args);
    let serviceInvocation = null;
    if (serviceInputs.size >= 1) {
        serviceInvocation = await (0, invoke_translation_service_1.invokeTranslationService)(serviceInputs, args);
    }
    const changeSet = computeChangeSet(args, serviceInvocation);
    const results = computeCoreResults(args, serviceInvocation, changeSet);
    (0, core_util_1.logCoreResults)(args, results);
    return results;
}
exports.translateCore = translateCore;
