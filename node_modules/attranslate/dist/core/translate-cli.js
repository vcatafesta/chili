"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translateCli = exports.formatCliOptions = void 0;
const tslib_1 = require("tslib");
const translate_core_1 = require("./translate-core");
const fs_1 = require("fs");
const tset_ops_1 = require("./tset-ops");
const util_1 = require("../util/util");
const core_util_1 = require("./core-util");
const path_1 = (0, tslib_1.__importDefault)(require("path"));
const file_format_definitions_1 = require("../file-formats/file-format-definitions");
const service_definitions_1 = require("../services/service-definitions");
const matcher_definitions_1 = require("../matchers/matcher-definitions");
async function resolveOldTarget(args, targetFileFormat) {
    const targetPath = path_1.default.resolve(args.targetFile);
    const targetDir = path_1.default.dirname(targetPath);
    (0, util_1.checkDir)(targetDir, { errorHint: "Target path" });
    if ((0, fs_1.existsSync)(targetPath)) {
        return await (0, core_util_1.readTFileCore)(targetFileFormat, {
            path: args.targetFile,
            lng: args.targetLng,
            format: targetFileFormat,
        });
    }
    else {
        return null;
    }
}
function formatCliOptions(options) {
    return `${options.map((o) => `"${o}"`).join(", ")}`;
}
exports.formatCliOptions = formatCliOptions;
async function translateCli(cliArgs) {
    var _a;
    checkForEmptyStringOptions(cliArgs);
    const fileFormats = (0, file_format_definitions_1.getTFileFormatList)();
    const services = (0, service_definitions_1.getTServiceList)();
    const matchers = (0, matcher_definitions_1.getTMatcherList)();
    if (!services.includes(cliArgs.service)) {
        (0, util_1.logFatal)(`Unknown service "${cliArgs.service}". Available services: ${formatCliOptions(services)}`);
    }
    if (!matchers.includes(cliArgs.matcher)) {
        (0, util_1.logFatal)(`Unknown matcher "${cliArgs.matcher}". Available matchers: ${formatCliOptions(matchers)}`);
    }
    if (!fileFormats.includes(cliArgs.srcFormat)) {
        (0, util_1.logFatal)(`Unknown source format "${cliArgs.srcFormat}". Available formats: ${formatCliOptions(fileFormats)}`);
    }
    const srcFileFormat = cliArgs.srcFormat;
    if (!fileFormats.includes(cliArgs.targetFormat)) {
        (0, util_1.logFatal)(`Unknown target format "${cliArgs.targetFormat}". Available formats: ${formatCliOptions(fileFormats)}`);
    }
    const targetFileFormat = cliArgs.targetFormat;
    (0, util_1.checkNotDir)(cliArgs.srcFile, { errorHint: "srcFile" });
    const src = await (0, core_util_1.readTFileCore)(srcFileFormat, {
        path: cliArgs.srcFile,
        lng: cliArgs.srcLng,
        format: srcFileFormat,
    });
    if (!src.size) {
        (0, util_1.logFatal)(`${(0, util_1.getDebugPath)(cliArgs.srcFile)} does not contain any translatable content`);
    }
    const oldTarget = await resolveOldTarget(cliArgs, targetFileFormat);
    const coreArgs = {
        src,
        srcLng: cliArgs.srcLng,
        oldTarget,
        targetLng: cliArgs.targetLng,
        service: cliArgs.service,
        serviceConfig: (_a = cliArgs.serviceConfig) !== null && _a !== void 0 ? _a : null,
        matcher: cliArgs.matcher,
    };
    const result = await (0, translate_core_1.translateCore)(coreArgs);
    const flushTarget = !oldTarget || !(0, tset_ops_1.areEqual)(oldTarget, result.newTarget);
    if (flushTarget) {
        console.info(`Write target ${(0, util_1.getDebugPath)(cliArgs.targetFile)}`);
        await (0, core_util_1.writeTFileCore)({
            path: cliArgs.targetFile,
            tSet: result.newTarget,
            lng: cliArgs.targetLng,
            changeSet: result.changeSet,
            format: targetFileFormat,
        });
    }
    if (!flushTarget) {
        console.info(`Target is up-to-date: '${cliArgs.targetFile}'`);
    }
}
exports.translateCli = translateCli;
// function parseBooleanOption(rawOption: string, optionKey: string): boolean {
//   const option = rawOption.trim().toLowerCase();
//   if (option === "true") {
//     return true;
//   } else if (option === "false") {
//     return false;
//   } else {
//     logFatal(
//       `Invalid option '--${optionKey}=${rawOption}'. Should be either true or false.`
//     );
//   }
// }
function checkForEmptyStringOptions(args) {
    Object.keys(args).forEach((key) => {
        const arg = args[key];
        if (typeof arg === "string" && (arg === "" || !arg.trim().length)) {
            (0, util_1.logFatal)(`option '--${key}' is empty -> Either omit it or provide a value`);
        }
    });
}
