#!/usr/bin/env bash

export PS4=$'${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
#set -x
#set -e

# 	fetch - search, install, create, remove, upgrade packages compatible with:
# 	Chili GNU/Linux - https://github.com/vcatafesta/ChiliOS
#	Chili GNU/Linux - https://chililinux.com
#	Chili GNU/Linux - https://chilios.com.br
# 	MazonOS GNU/Linux - http://mazonos.com
#
# 	Created: 2019/04/05
# 	Altered: 2022/11/06
#
# 	Copyright (c) 2019-2022, Vilmar Catafesta <vcatafesta@gmail.com>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# 	fetch uses quite a few external programs during its execution. You
# 	need to have at least the following installed for makepkg to function:
#  	awk, bsdtar (libarchive), bzip2, coreutils, fakeroot, file, find (findutils),
#   	gettext, gpg, grep, gzip, sed, tput (ncurses), xz
# 	contains portion of software https://bananapkg.github.io/
#########################################################################
# Import lib
readonly _VERSION_="3.39.20221106"
LIBRARY=${LIBRARY:-'/usr/share/fetch'}
SYSCONFDIR=${SYSCONFDIR:-'/etc/fetch'}
[[ -f "${LIBRARY}/core.sh" ]] && source "${LIBRARY}/core.sh"

# var bool
declare -i ERR_ERROR=1
declare -i ERR_OK=0
declare -i true=1
declare -i false=0
declare -i LINSTALLED=2

fn_debug() {
	# debug
	#declare -A cores=( [bla]=0 [red]=1 [gre]=2 [yel]=3 [blu]=4 [mag]=5 [cya]=6 [whi]=7 )
	#fg=${cores[bla]}
	#bg=${cores[red]}
	#export PS4=$'+\t${0##*/}[$LINENO] '
	#set -x
	#set -Eeuo pipefail
	#trap 'echo "${BASH_SOURCE}:${LINENO}:${FUNCNAME:-}"' ERR

	setvarcolors
	export PS4=$'${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
	#set -x
	#set -e
	# end debug

	#set -a 						# Enable allexport using single letter syntax
	#set -o allexport 		# Enable using full option name syntax
	#set +a 						# Disable allexport using single letter syntax
	#set +o allexport 		# Enable using full option name syntax
}

configure() {
	export LC_ALL=C
	export LANG=C
	readonly DEPENDENCIES=(which find tar zstd curl sed sort grep cat awk tput stat tee lynx numfmt)
	unset CDPATH
	unset GREP_OPTIONS

	[[ -s "$SYSCONFDIR/fetch.conf" ]] || sh_touchconf
	[[ -s "$SYSCONFDIR/fetch.conf" ]] && source "$SYSCONFDIR/fetch.conf" || return 1

	# files
	FOLDERS_METAPACKAGES='folders_metapackages.csv'
	METAPACKAGES='metapackages.csv'
	PACKAGES_SPLIT='packages-split.csv'
	PACKAGES_INSTALLED_SPLIT='packages-installed-split.csv'
	PACKAGES_IN_CACHE='packages-in-cache.csv'

	#var public
	declare -a public_pkg_not_found=()
	declare -a public_pkg=()
	declare -a public_pkg_deps=()
	declare -i public_ntotal_pkg_installed=0
	declare -i public_ntotal_pkg_listed=0
	declare -a public_ListSearch=
	declare -i public_len_count_pkg=0

	# default
	export PKG_EXT SEP SITE GITSITE RAW APP
	export CACHEDIR CACHEDIR_ARCHIVES CACHEDIR_SEARCH
	export CACHEDIR_LIST CACHEDIR_DESC CACHEDIR_REMO
	export VARLIB_FETCH
	export DESCME
	export ALIEN_CACHE_DIR="${ALIEN_CACHE_DIR:=/var/cache/pacman/pkg}"
	export ALIEN_VARLIB="/var/lib/pacman/local"

	verbose=0
	SEP=','
	: "${PKG_EXT:='chi.zst'}" # se PKG_EXT não estiver definida, recebe 'chi.zst'
	: "${GITSITE:=0}"         # se GITSITE não estiver definida, recebe 0
	SITE="${PKG_SITE:=https://chililinux.com}"
	RAW="${PKG_RAW:=https://raw.githubusercontent.com/vcatafesta/ChiliOS/master}"
	APP="fetch"
	APP="${0##*/}"
	CACHEDIR="${CACHEDIR:=/var/cache/$APP}"
	CACHEDIR_ARCHIVES="$CACHEDIR/archives"
	CACHEDIR_SEARCH="$CACHEDIR/search"
	CACHEDIR_LIST="$CACHEDIR/list"
	CACHEDIR_DESC="$CACHEDIR/desc"
	CACHEDIR_REMO="$CACHEDIR/remove"
	DESCME='info/desc'
	VARLIB_FETCH="/var/lib/$APP"
	CHILI_OS=$true

	#temporary
	TMP_DIR_ROOT="$(mktemp -d -u)"
	TMP_DIR_BACKUP="$TMP_DIR_ROOT/$APP/$CACHEDIR_SEARCH"
	TMP_DIR_FOLDERS="$TMP_DIR_ROOT/$APP/$CACHEDIR/folders"

	# regex's
	#DATE_RE='(\d{4}-\d{2}-\d{2}\s\d{2}:\d{2})'	#2022-03-16 14:22
	#RE_ALIEN='.+\.zst$|.+\.xz$' 						#VC
	#RE_ALIEN='.+\.[zst|xz]+$'  						#VC
	RE_ALIEN='.+\.(zst|xz)$' #Bagatini/Blau

	if [[ "$PKG_EXT" = "chi.zst" ]]; then
		CHILI_OS=$true
		#PKG_RE='^([a-z-]+)(-)([0-9\\.]+)(-)([0-9])(-)(.*)(.chi.zst)$'
		#PKG_RE='([a-zA-Z0-9]+(-[a-zA-Z0-9]+)*)-(([0-9]+(\.[0-9]+)*)(-([0-9]+))?)-([^.]+).*'
		#PKG_RE='(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst' 				#SOEN
		#		PKG_RE='(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst'    			#VC
		PKG_RE='(.+)-(([^-]+)-([0-9]+))-([^.]+)(\.chi\.zst)$' #VC
		#		PKG_RE_LYNX='(?!.*\/)(.*)-(([^-]+)-([0-9]+))-([^.]+)(\.chi\.zst)$'
		#		PKG_RE_FULL1='(?:")(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst(?="><a)'
		#		PKG_RE_FULL2='(?:e">)(.+)-(([^-]+)-([0-9]+))-([^.]+)(\.chi)(\.zst)(?=<\/a)'
		GREP_RE='.chi\.zst\"'
		#SED_RE='^.+>(.+)-(([^-]+)-([0-9]+))-([^.]+)(.chi.zst)<.a>.*([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2}).*[ ]([0-9]+k?)(.*)'
		#SED_RE='^.+="(.+)-(([^-]+)-([0-9]+))-([^.]+)(.chi.zst)".+<.a>.*([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2}).+[ ]([0-9]+k?)(.*)'
		SED_RE='^.*["|\/](.+)-(([^-]+)-([0-9]+))-([^.]+)(.chi.zst)".+<.a>.*([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2}).+[ ]([0-9]+k?).*'
		#		FETCH_RE='-[^a-z]+?[^-]+-[0-9].*-'
		#		FETCH_RE='-[^-]+-[0-9]-'
		FETCH_RE='-[^-]+[0-9]+-[^.]+.chi.*'
	else
		CHILI_OS=$false
		#PKG_RE='(.+)-(([^-]+)-([0-9]+))\.mz' 						#SOEN
		PKG_RE='(.+)-(([^-]+)-([0-9]))\.mz' #VC
		#		PKG_RE_LYNX='(?!.*\/)(.+)-(([^-]+)-([0-9]))\.mz$'		#VC
		GREP_RE='.mz\"'
		SED_RE='^.+href="(.+)-(([^-]+)-([0-9]))()(\.mz\b)".+([0-9]{4}-[0-9]{2}-[0-9]{2}|[0-9]{2}-[A-z]{3}-[0-9]{4})[ ]([0-9]{2}:[0-9]{2})[ ]+([0-9]+[.]?[0-9]+.?).+'
		FETCH_RE='-[^-]+-[0-9]+[.]'
	fi
}

sh_touchconf() {
	[[ -d "${SYSCONFDIR}" ]] || mkdir -p "${SYSCONFDIR}" >/dev/null 2>&-
	cat >"$SYSCONFDIR/fetch.conf" <<-'_EOF_'
		######################################################################
		# fetch.conf
		######################################################################
		# extension of packages: chili=chi.zst, mazonos=mz
		#PKG_EXT='mz'       # http://mazonos.com
		PKG_EXT='chi.zst'  # https://chililinux.com | https://github.com/vcatafesta/ChiliOS

		# packages hosted on GITHUB repository: yes='1', not='0'
		GITSITE='0'

		# distro hosting website/packages
		#PKG_SITE='https://github.com/vcatafesta/ChiliOS/tree/master'  # for use set GITSITE=1
		PKG_SITE='https://chililinux.com'                                             # for use set GITSITE=0
		#PKG_SITE='https://chilios.com.br'                                             # for use set GITSITE=0
		#PKG_SITE='https://chililinux.org'                                            # for use set GITSITE=0
		#PKG_SITE='https://chililinux.online'                                        # for use set GITSITE=0
		#PKG_SITE='https://sybernet.com.br'                                           # for use set GITSITE=0
		#PKG_SITE='http://localhost'                                                     # for use set GITSITE=0
		#PKG_SITE='http://mazonos.com'                                                  # for use set GITSITE=0

		#not needed change
		PKG_RAW='https://raw.githubusercontent.com/vcatafesta/ChiliOS/master'

		# configuration for generation new packages
		MAINTAINER='Vilmar Catafesta <vcatafesta@gmail.com>'
		GPG_SIGN='0'
		REWRITE_SIGN='1'
		CREATE_SHA256='0'
		DESC_BUILD='1'
		URL='https://www.linuxfromscratch.org/lfs/view/stable/'
		LICENSE='GPL2'
		LFS_VERSION='11.1'
		LFS_INIT='SYSTEMD'
		ARCH='x86_64'
		DISTRO='chili'
		GITDIR='/github/ChiliOS'
		PKGCORE="$GITDIR/packages/core"
		CACHEDIR='/var/cache/fetch'
		ALIEN_CACHE_DIR='/var/cache/pacman/pkg'
		IGNOREPKG=('glibc' 'file')

		#end
	_EOF_
}

clinesplit() {
	printf "%s%s%s%s%s%s%s%s" \
		"${aPKGSPLIT[$PKG_BASE]}$SEP" \
		"${aPKGSPLIT[$PKG_VERSION]}$SEP" \
		"${aPKGSPLIT[$PKG_BUILD]}$SEP" \
		"${aPKGSPLIT[$PKG_FULLNAME]}$SEP" \
		"${aPKGSPLIT[$PKG_PKG_FOLDER_DIR]}/${aPKGSPLIT[$PKG_FULLNAME]}$SEP" \
		"${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP" \
		"${aPKGSPLIT[$PKG_SIZE]}$SEP" \
		"${aPKGSPLIT[$PKG_FOLDER_DIR]}"
}

clineascan() {
	printf '%s' "${aPKGARRAY[0]}$SEP${aPKGARRAY[1]}$SEP${aPKGARRAY[2]}$SEP${aPKGARRAY[3]}$SEP${aPKGARRAY[4]}$SEP${aPKGARRAY[5]}$SEP${aPKGARRAY[6]}"
}

clineinstallascan() {
	printf "%s" "${aPKGARRAY[5]}  $(size_to_human "${aPKGARRAY[6]}")"
}

sh_arraypkgfullVET() {
	OLDIFS=$IFS
	local file_list_packages="$1"
	[[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"

	public_len_count_pkg=0

	declare -a public_pkg_base
	declare -a public_pkg_version
	declare -a public_pkg_build
	declare -a public_pkg_fullname
	declare -a public_pkg_dirfullname
	declare -a public_pkg_base_version
	declare -a public_pkg_size
	declare -a public_pkg_site
	local ind=0

	((verbose >= 2)) && log_msg "Checking packages"

	while IFS=, read -r public_pkg_base[$ind] \
		public_pkg_version[$ind] \
		public_pkg_build[$ind] \
		public_pkg_fullname[$ind] \
		public_pkg_dirfullname[$ind] \
		public_pkg_base_version[$ind] public_pkg_size[$ind] \
		public_pkg_site[$ind]; do
		((ind++))
	done <$file_list_packages
	public_len_count_pkg=${#public_pkg_base[*]}
	IFS=$OLDIFS
	return 0
}

sh_arraypkgfullIFS() {
	OLDIFS=$IFS
	local file_list_packages="$1"
	[[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"

	public_len_count_pkg=0
	export public_pkg_base
	export public_pkg_version
	export public_pkg_build
	export public_pkg_fullname
	export public_pkg_dirfullname
	export public_pkg_base_version
	export public_pkg_size
	export public_pkg_site

	((verbose >= 2)) && log_msg "Checking packages"

	while IFS=, read -r fld1 fld2 fld3 fld4 fld5 fld6 fld7 fld8; do
		public_pkg_base+=("${fld1}")
		public_pkg_version+=("${fld2}")
		public_pkg_build+=("${fld3}")
		public_pkg_fullname+=("${fld4}")
		public_pkg_dirfullname+=("${fld5}")
		public_pkg_base_version+=("${fld6}")
		public_pkg_size+=("${fld7}")
		public_pkg_site+=("${fld8}")
	done <$file_list_packages

	public_len_count_pkg=${#public_pkg_base[*]}
	IFS=$OLDIFS
	return 0
}

sh_arraypkgfull() {
	local file_list_packages="$1"
	[[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
	((verbose >= 2)) && log_msg "Checking packages"

	public_pkg_base=($(awk -F$SEP '{ print $1 }' $file_list_packages))
	public_pkg_version=($(awk -F$SEP '{ print $2 }' $file_list_packages))
	public_pkg_build=($(awk -F$SEP '{ print $3 }' $file_list_packages))
	public_pkg_fullname=($(awk -F$SEP '{ print $4 }' $file_list_packages))
	public_pkg_dirfullname=($(awk -F$SEP '{ print $5 }' $file_list_packages))
	public_pkg_base_version=($(awk -F$SEP '{ print $6 }' $file_list_packages))
	public_pkg_size=($(awk -F$SEP '{ print $7 }' $file_list_packages))
	public_pkg_site=($(awk -F$SEP '{ print $8 }' $file_list_packages))

	public_len_count_pkg=${#public_pkg_base[*]}
	return 0
}

sh_arraypkgfullMAPFILE() {
	local file_list_packages=$1
	[[ $# -eq 0 ]] && file_list_packages="$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
	public_len_count_pkg=0

	((verbose >= 2)) && log_msg "Checking packages"
	#	foo() { echo "|$2|"; }; mapfile -t -d, -n7 -c1 -C 'foo' <"$file_list_packages"
	#	public_pkg_base=${public_pkg_base[@]//,*}

	callback() {
		local IFS=,
		eval linha$1=\($2\)
	}
	mapfile -t -c1 -C callback <"$file_list_packages"
	#declare -p linha{0..2}
	#L=1;	C=4; eval echo "\${linha$L[C]}"

	campo=(base version build fullname dirfullname base_version size site)

	for i in {0..5386}; do
		for j in ${!campo[*]}; do
			eval public_pkg_${campo[j]}+=\("\${linha${i}[j]}"\)
		done
	done

	#	for i in {0..5386}
	#	do
	#		#  eval echo "\${linha$i[6]}"
	#		#  eval val="\${linha$i[6]}"
	#		#  pkg_size+=("$val")
	#		eval public_pkg_base+=("\${linha$i[0]}")
	#		eval public_pkg_version+=("\${linha$i[1]}")
	#		eval public_pkg_build+=("\${linha$i[2]}")
	#		eval public_pkg_fullname+=("\${linha$i[3]}")
	#		eval public_pkg_dirfullname+=("\${linha$i[4]}")
	#		eval public_pkg_base_version+=("\${linha$i[5]}")
	#		eval public_pkg_size+=("\${linha$i[6]}")
	#		eval public_pkg_site+=("\${linha$i[7]}")
	#	done

	public_len_count_pkg=${#public_pkg_base[*]}
	return 0
}

sh_ascanpkg() {
	#	local pkgsearch="^$1$"
	local pkgsearch="$1"
	local pos="$2"
	local indice
	aPKGARRAY=()

	indice=$(awk -F$SEP -v var="^$pkgsearch$" -v field=$((++pos)) '$field ~ var { print NR}' "$CACHEDIR_SEARCH/$PACKAGES_SPLIT")

	#	case $pos in
	#		0) indice=$(awk -F$SEP -v var="$pkgsearch" -v field=1 '$'"field"' ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		0) indice=$(awk -F$SEP -v var="$pkgsearch" -v field=$((++pos)) '$field ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		0) indice=$(awk -F$SEP -v var="$pkgsearch" '$1 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		1) indice=$(awk -F$SEP -v var="$pkgsearch" '$2 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		2) indice=$(awk -F$SEP -v var="$pkgsearch" '$3 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		3) indice=$(awk -F$SEP -v var="$pkgsearch" '$4 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		4) indice=$(awk -F$SEP -v var="$pkgsearch" '$5 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		5) indice=$(awk -F$SEP -v var="$pkgsearch" '$6 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		6) indice=$(awk -F$SEP -v var="$pkgsearch" '$7 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#		7) indice=$(awk -F$SEP -v var="$pkgsearch" '$8 ~ var { print NR}' /var/cache/fetch/search/packages-split.csv);;
	#	esac

	if [[ -z $indice ]]; then
		return 1
	fi

	indice=$(printf "%d %d %d %d %d %d %d %d %d %d" $indice) # corrigir bug do retorno do indice pelo awk quando varios pacotes mesmo nome
	indice=${indice%% *}
	((--indice))

	aPKGARRAY=("${public_pkg_base[$indice]}"
		"${public_pkg_version[$indice]}"
		"${public_pkg_build[$indice]}"
		"${public_pkg_fullname[$indice]}"
		"${public_pkg_dirfullname[$indice]}"
		"${public_pkg_base_version[$indice]}"
		"${public_pkg_size[$indice]}"
		"${public_pkg_site[$indice]}"
	)
	strstatus=''
	if grep -q ^"$pkgsearch$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"; then
		strstatus='[installed]'
	fi
	return 0
}

sh_ascanpkgGREP() {
	local pkgsearch="$1"
	local pos="$2"
	local indice=0
	aPKGARRAY=()

	case $pos in
	0) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_base[@]}")") ;;
	1) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_version[@]}")") ;;
	2) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_build[@]}")") ;;
	3) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_fullname[@]}")") ;;
	4) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_dirfullname[@]}")") ;;
	5) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_base_version[@]}")") ;;
	6) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_size[@]}")") ;;
	7) indice=$(grep -Po -n -m 1 "^$pkgsearch$" <<<"$(printf '%s\n' "${public_pkg_site[@]}")") ;;
	esac

	if [[ -z $indice ]]; then
		return 1
	fi
	indice="${indice%%:*}"
	((--indice))
	aPKGARRAY=("${public_pkg_base[$indice]}"
		"${public_pkg_version[$indice]}"
		"${public_pkg_build[$indice]}"
		"${public_pkg_fullname[$indice]}"
		"${public_pkg_dirfullname[$indice]}"
		"${public_pkg_base_version[$indice]}"
		"${public_pkg_size[$indice]}"
		"${public_pkg_site[$indice]}"
	)
	return 0
}

sh_ascanpkgOLD() {
	local pkgsearch="$1"
	local pos="$2"
	local indice=0
	aPKGARRAY=()

	case $pos in
	0) indice=$(printf "%s\n" "${public_pkg_base[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	1) indice=$(printf "%s\n" "${public_pkg_version[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	2) indice=$(printf "%s\n" "${public_pkg_build[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	3) indice=$(printf "%s\n" "${public_pkg_fullname[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	4) indice=$(printf "%s\n" "${public_pkg_dirfullname[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	5) indice=$(printf "%s\n" "${public_pkg_base_version[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	6) indice=$(printf "%s\n" "${public_pkg_size[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	7) indice=$(printf "%s\n" "${public_pkg_site[@]}" | grep -n -m 1 "^${pkgsearch}$" | cut -d ":" -f1) ;;
	esac

	if [[ -z $indice ]]; then
		return 1
	fi

	((--indice))
	aPKGARRAY=("${public_pkg_base[$indice]}"
		"${public_pkg_version[$indice]}"
		"${public_pkg_build[$indice]}"
		"${public_pkg_fullname[$indice]}"
		"${public_pkg_dirfullname[$indice]}"
		"${public_pkg_base_version[$indice]}"
		"${public_pkg_size[$indice]}"
		"${public_pkg_site[$indice]}"
	)
	return 0
}

sh_cabec() { #$1 nfiles
	printf "(${pink}%04d)${green} sts package%47sversion%8s%11ssize fullbasename\n" "$1"
}

sh_write() {
	local pkgsearch="$1"
	local pos="$2"
	local pkgCheckNumber="$3"
	local strstatus=''
	local status="$4"
	local clisting="$5"
	local LSCAN=$true

	[[ "$pos" = '-1' ]] && LSCAN=$false
	((LSCAN)) && sh_ascanpkg "$pkgsearch" "$pos"
	[[ -z "$status" ]] && status=' A '
	[[ "$clisting" == 'N' ]] && return 0
	[[ "$status" = ' I ' ]] && strstatus='installed'

	if ((verbose >= 2)); then
		if grep -q ^"$pkgsearch$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"; then
			strstatus='installed'
			[[ "$status" != 'dep' ]] && status=' I '
		else
			strstatus='         '
			[[ "$status" != 'dep' ]] && status=' N '
		fi
		printf "${green}%s(%04d) ${cyan}%-3s ${orange}%-43s$cyan $strstatus ${reset}%-15s%15s %s\n" \
			"" \
			"$pkgCheckNumber" \
			"$status" \
			"${aPKGARRAY[0]}" \
			"${aPKGARRAY[1]}" \
			"$(size_to_human "${aPKGARRAY[6]}")" \
			"${aPKGARRAY[3]}"
	else
		log_msg "[$pkgCheckNumber]${orange}${aPKGARRAY[0]}" # resumido
	fi
	return 0
}

sh_footer() {
	local pkgCheckNumber=$1
	log_msg "${green}($pkgCheckNumber)${reset} package(s) found."
}

# -La
sh_list() {
	local param="$@"
	local nfiles
	local s x y
	local status=' A '
	local SEARCH_CUT='-f1'
	local pkg
	local aout
	local cListSearch

	LLIST=$true
	((verbose >= 2)) && log_msg "Reading package lists in the repository"
	if (($#)); then
		for s in "${param[@]}"; do
			cListSearch+="$s "
		done
	fi

	if [[ -z "$cListSearch" ]]; then
		#		if (( LALL )); then
		pkg=${public_pkg_base[@]}
		aout=${public_pkg_base_version[@]}
		#		else
		#			log_failure_msg "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
		#			return 1
		#		fi
	else
		for x in ${cListSearch}; do
			((LEXACT)) && y="^$x$SEP" || y="$x"
			if tmp=$(grep "$y" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT"); then
				pkg+=($(cut -d$SEP -f1 <<<$tmp))
				aout+=($(cut -d$SEP -f5 <<<$tmp))
			else
				log_failure_msg "${red}error${reset}: alvo não encontrado: $x"
			fi
		done
	fi

	if ! nfiles=$(lenarray "${pkg[*]}"); then
		return 1
	fi

	fn_writetable "${pkg[*]}" '0' $nfiles
	return $?
}

# -Li
sh_listinstalled() {
	local param="$@"
	local pkgNumber=0
	local s
	local n
	local cListSearch
	local ntotalpkg=0
	local arr

	((verbose >= 2)) && log_msg "Listing installed packages"
	LLIST=$true
	LDEPS=$false
	SPLITPOS='0'

	[[ -z "${param}" ]] && LALL=$true || LALL=$false
	fn_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" "$param"
}

# -Li
function fn_listpkgdisp() {
	local file_list_package="$1"
	shift
	local file_list_installed="$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	local param="$*"
	local s
	local i
	local SEARCH_CUT="-f5"
	local nstatus=0
	local pgk_grep
	local ncontapkg=0
	local aBidi=()

	[[ -e $file_list_installed ]] || printf '' >"${file_list_installed}"

	#TODO: verificar necessidade
	#sh_arraypkgfull "$file_list_package"
	#TODO: verificar necessidade

	public_ntotal_pkg_installed=$(sh_linecount "$file_list_installed")
	public_ntotal_pkg_listed=$public_ntotal_pkg_installed
	public_pkg=()
	public_pkg_deps=()
	public_ListSearch=$param
	public_pkg_not_found=()

	if [[ "$SPLITPOS" == "" ]]; then
		SPLITPOS='4'
		SEARCH_CUT='-f5'
		AWK_CUT='$5'
	elif [[ "$SPLITPOS" == "0" ]]; then
		SEARCH_CUT='-f1'
		AWK_CUT='$1'
	elif [[ "$SPLITPOS" == "4" ]]; then
		SEARCH_CUT='-f5'
		AWK_CUT='$5'
	elif [[ "$SPLITPOS" == "5" ]]; then
		SEARCH_CUT='-f6'
		AWK_CUT='$6'
	fi

	if ((LALL)) || [[ -z "$public_ListSearch" ]]; then
		if ((LALL)); then
			mapfile -t public_pkg < <(awk -F$SEP '{print '$AWK_CUT'}' "$file_list_package")
		else
			log_failure_msg2 "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
			exit 1
		fi
	else
		for x in ${public_ListSearch[*]}; do
			if ((LEXACT)); then
				pkg_grep=$(grep ^"$x$SEP" "$file_list_package" | cut -d$SEP "$SEARCH_CUT")
			else
				pkg_grep=$(grep "$x" "$file_list_package" | cut -d$SEP "$SEARCH_CUT")
			fi

			if [[ -n "$pkg_grep" ]]; then
				for n in ${pkg_grep[*]}; do
					public_pkg+=("$n")
				done
			else
				if ! ((LSKIPERROR)); then
					if ((LREMOVE)); then
						log_failure_msg "${red}error: ${orange}$x ${reset}target was ${red}NOT INSTALLED. ${reset}Use the ${yellow}${0##*/} -Sr ${reset}option to rebuild installed packages."
					else
						log_failure_msg "${red}error: ${orange}$x ${reset}target was ${red}NOT found. ${reset}Use the ${yellow}-Ss ${reset}option to search. "
					fi
					exit 1
				else
					log_failure_msg "${red}error${reset}: ${orange}${x} ${reset}target was ${red}NOT ${reset}found. ${yellow}Skipping"
				fi
				public_pkg_not_found+=("$x")
			fi

			if ! ((LREMOVE)); then
				if ! ((LSEARCHONLY)); then
					pkginstalled=$(grep ^"$x"$SEP "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" | cut -d$SEP "$SEARCH_CUT")
					if [[ -n "$pkginstalled" && "${pkginstalled##*/}" = "${pkg_grep##*/}" ]]; then
						log_failure_msg "${yellow}atenção${reset}: ${orange}${pkginstalled##*/} ${reset}está atualizado -- reinstalando."
					fi
				fi
			fi
		done
	fi

	if ((public_ntotal_pkg_listed = $(lenarray "${public_pkg[*]}"))); then
		nstatus=$public_ntotal_pkg_listed
		if ! ((LREMOVE)); then
			if ((LDEPS)); then
				sh_getdeps $LDEPS || return 1
				public_pkg+=(${public_pkg_deps[*]})
			fi
		fi
		#sanitize
		public_pkg=($(sh_adel ${public_pkg[*]}))
		public_ntotal_pkg_listed=$(lenarray "${public_pkg[*]}")
		fn_writetable "${public_pkg[*]}" '0' $public_ntotal_pkg_listed $nstatus
		return 0
	fi
	return 1
}

fn_writetable() {
	local arr=("$1")
	local campo="$2"
	local nfiles=$3
	local nstatus=$4
	local nlen
	local status

	if ((nlen = $(lenarray "${arr[*]}"))); then
		if ((verbose >= 2)); then
			sh_cabec "$nfiles"
			pkgNumber=0

			for i in ${arr[*]}; do
				if ((verbose >= 2)); then
					[[ -n "$nstatus" ]] && ((pkgNumber > nstatus)) && status='dep' || status=' S '
					#					if   grep -q ^"$i$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT";
					#					then status=' I '
					#					else status=' A '
					#					fi
				fi
				((LLIST)) && sh_write "$i" "$SPLITPOS" $((++pkgNumber)) "$status"
				#				(( LLIST )) && sh_write "$i" $campo $((++pkgNumber)) "$status"
			done
		else
			if ((LLIST)); then
				if ((LTABLE)); then
					for i in ${arr[*]}; do
						#						if sh_ascanpkg "$i" $campo; then
						if sh_ascanpkg "$i" "$SPLITPOS"; then
							repo=${aPKGARRAY[4]%%/*}
							printf "%-60s\t%s\t%15s\n" \
								"${bold}${pink}$repo/${white}${aPKGARRAY[0]}-${black}${aPKGARRAY[1]}" \
								"${red}$(size_to_human "${aPKGARRAY[6]}")" \
								"${cyan}$strstatus"
						fi
					done
					printf "%s\n" "${reset}Packages ($nfiles)"
				else
					printf "${bold}${black}%s\n${reset}Packages ($nfiles)\n" "${arr[*]}"
					printf "\t%s\n" "${yellow}TIP: ${red}use the option --table or --verbose for more details"
				fi
			fi
			return 0
		fi
	fi
	printf "${yellow}(%05d) %s\n" "$nfiles" "${cyan}packages listed${reset}"
	return 0
}

sh_checknet() {
	# have internet?
	((verbose >= 2)) && log_info_msg "${cyan}Testing internet from ${SITE}"
	curl --insecure $SITE >/dev/null 2>&- ||
		{
			((verbose >= 2)) && evaluate_retval
			log_failure_msg2 "No route to server ($SITE) - ABORTED."
			return 1
		}
	((verbose >= 2)) && evaluate_retval
	return 0
}

sh_selfupdate() {
	local param="$@"

	if ! ((LAUTO)) || ! ((LFORCE)); then
		echo
		conf "Update ${0##*/} from internet?"
		LAUTO=$?
	fi

	if ((LAUTO)) || ((LFORCE)); then
		local link="$PKG_RAW/updater/src/fetch"
		local tmp_dir_full="/tmp/${APP}"
		local tmp_dir="/tmp/${APP}/src"

		#internet?
		sh_checknet || return 1

		log_msg "Ok, let's do it..."
		#Ok, Puxe o arquivo do repositorio agora!
		[[ -d "${tmp_dir_full}" ]] && rm -r "${tmp_dir_full}"
		[[ -d "${tmp_dir}" ]] || mkdir -p "${tmp_dir}"
		pushd "${tmp_dir}" >/dev/null 2>&- || return 1
		log_info_msg "${cyan}Clonando $link"
		curl --insecure --silent --remote-name "${link}"
		evaluate_retval

		log_info_msg "${cyan}Permission and Copy archives"
		chmod +x "${tmp_dir}/fetch"
		evaluate_retval

		log_info_msg "${cyan}Copying file ${yellow}fetch ${red}to ${yellow}${0}"
		cp -f "${tmp_dir}/fetch" "$0"
		evaluate_retval

		log_info_msg "${cyan}Removing temporary files"
		[[ -d "${tmp_dir_full}" ]] && rm -r "${tmp_dir_full}"
		evaluate_retval
		log_info_msg "${violet}${0##*/} updated successfully, enjoy!"
		evaluate_retval
		exit 0
	fi
	return 1
	sh_cdroot
}

sh_clean() {
	local param="$@"
	local lRetval=$false
	local nfiles

	nfiles=$(find "$CACHEDIR_ARCHIVES" -type f -iname "*.$PKG_EXT" -type f | wc -l)
	if ! ((nfiles)); then
		printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
		log_msg "${yellow}($nfiles) ${cyan}find packages in cache"
		return $lRetval
	fi

	if ! ((LAUTO)); then
		printf '%s\n' "Pacotes a serem mantidos:"
		printf '%s\n' "      Todos os pacotes instalados localmente"
		printf "\n"
		printf '%s\n' "Cache directory: $CACHEDIR_ARCHIVES/"
		conf "${blue}:: ${reset}Do you want to remove all packages from the cache?"
		LAUTO=$?
	fi

	if ((LAUTO)); then
		log_msg "${pink}Deleting downloaded package files"
		if [[ -d "$CACHEDIR_ARCHIVES" ]]; then
			rm -f "$CACHEDIR_ARCHIVES/*.$PKG_EXT*"
		else
			mkdir -p "$CACHEDIR_ARCHIVES"
		fi
		printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
		log_success_msg2 "${yellow}($nfiles) ${cyan}packages deleted"
		lRetval=$true
	fi
	sh_cdroot
	return $lRetval
}

sh_checkdir() {
	local i
	local -a aDir
	aDir+=("$CACHEDIR_ARCHIVES")
	aDir+=("$CACHEDIR_SEARCH")
	aDir+=("$CACHEDIR_LIST")
	aDir+=("$CACHEDIR_DESC")
	aDir+=("$CACHEDIR_REMO")

	((verbose >= 2)) && log_msg "Checking job directories"

	for i in "${aDir[@]}"; do
		((verbose >= 2)) && log_info_msg "$i"
		if [[ -d "$i" ]]; then
			((verbose >= 2)) && evaluate_retval
		else
			mkdir -p "$i" >/dev/null 2>&-
			((verbose >= 2)) && evaluate_retval
		fi
	done
	[[ -e "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" ]] || printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
	[[ -e "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" ]] || printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"

	return $?
}

# -Sy
fn_updaterepo() {
	verbose=2
	if ((LSELF)); then
		sh_selfupdate "$@"
		return $?
	fi

	local nfilesInReposit
	local nfilesInstalled
	local response
	local dw=("$FOLDERS_METAPACKAGES"
		"$METAPACKAGES"
		"$PACKAGES_SPLIT"
	)
	#internet?
	sh_checknet || return 1

	response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "${SITE}/repo/")
	if [[ $response -eq 404 ]]; then
		log_failure_msg "${red}error${reset}: $response Not Found ${orange}==> $SITE/repo/"
		return 1
	fi

	pushd "$CACHEDIR_SEARCH/" >/dev/null 2>&- || return 1
	sh_backup

	log_msg "${pink}Cleaning up ${CACHEDIR_SEARCH}/${reset}"
	for i in "${dw[@]}"; do
		rm -f "$CACHEDIR_SEARCH/$i"
	done

	log_msg "${pink}Updating file packages from ${SITE}/repo/${reset}"
	curl --silent --insecure -O "$SITE/repo/${dw[0]}" -O "${SITE}/repo/${dw[1]}" -O "${SITE}/repo/${dw[2]}"
	sh_cleaning
	unset FOLDER_TEMP

	nfilesInReposit=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_SPLIT")
	nfilesInstalled=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT")
	log_msg "${cyan}All list packages updated!${reset}"
	log_msg "${blue}($(strzero "$nfilesInReposit" 5)) packages in the repository${reset}"
	log_msg "${green}($(strzero "$nfilesInstalled" 5)) installed packages${reset}"
	echo
	log_msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd >/dev/null 2>&- || return 1
}

# -Syy
fn_update() {
	local Folders
	local FoldersInRepo
	local PackagesInFolders
	local MetaPkgInFolders
	local MetaInFolder
	local cstrvalue
	local response
	local count
	local nfilesInReposit
	local nfilesInstalled
	local nfilesInCache
	local oldverbose=$verbose
	local dw=("$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
		"$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES"
		"$CACHEDIR_SEARCH/$METAPACKAGES"
	)

	verbose=2
	if ((LSELF)); then
		sh_selfupdate "$@"
		return $?
	fi

	#internet?
	sh_checknet || return 1

	if [[ response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "$SITE/packages/") = "404" ]]; then
		log_failure_msg "${red}error${reset}: $response Not Found $orange==> $SITE/packages/"
		exit 1
	fi

	pushd "$CACHEDIR_SEARCH/" >/dev/null 2>&- || return 1
	sh_backup

	log_msg "${pink}Cleaning up $CACHEDIR_SEARCH/"
	for i in "${dw[@]}"; do
		printf '' >|"$i"
	done

	log_msg "${pink}Updating folders from $SITE"
	FoldersInRepo=$(lynx -listonly -nonumbers -dump -justify "$SITE/packages/" | grep -Po '.*packages\/\K.*?(?=\/)')

	log_msg "${pink}Synchronizing package databases from $SITE/packages/"
	#	spinner & SPINNERPID=$!

	for Folders in ${FoldersInRepo[*]}; do
		FOLDER_TEMP="$TMP_DIR_FOLDERS/$Folders"
		if [[ response=$(curl --compressed -k -s -w "%{http_code}\n" --url "$SITE/packages/$Folders/" --output "$FOLDER_TEMP") = "404" ]]; then
			log_failure_msg "${red}error${reset}: $response Not Found ${orange}==> $SITE/packages/$Folders/"
			exit 1
		fi
		mapfile -t SizePkgInFolders < <(sed -nE "s/$SED_RE/\9/p" "$FOLDER_TEMP")

		if [[ "$Folders" != "meta" ]]; then
			if ((CHILI_OS)); then
				mapfile -t PackagesInFolders < <(sed -nE "s/$SED_RE/\1-\2-\5\6/p" "$FOLDER_TEMP")
			else
				mapfile -t PackagesInFolders < <(sed -nE "s/$SED_RE/\1-\2\6/p" "$FOLDER_TEMP")
			fi
			count=0
			for pkgInFolder in "${PackagesInFolders[@]}"; do
				if [[ -n "$pkgInFolder" ]]; then
					sh_splitpkg "$pkgInFolder"
					pkg_size=$(human_to_bytes "${SizePkgInFolders[$count]}")
					echo "${aPKGSPLIT[$PKG_BASE]}$SEP${aPKGSPLIT[$PKG_VERSION]}$SEP${aPKGSPLIT[$PKG_BUILD]}$SEP${aPKGSPLIT[$PKG_FULLNAME]}$SEP${Folders}/${pkgInFolder}$SEP${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP${pkg_size}" >>"$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
					((++count))
				fi
			done
		else
			MetaPkgInFolders=$(lynx -listonly -nonumbers -dump "$SITE/packages/$Folders/" | grep -Po '.*\/\K.*')
			count=0
			for MetaInFolder in "${MetaPkgInFolders[@]}"; do
				echo "$Folders/$MetaInFolder" >>"$FOLDERS_METAPACKAGES"
				echo "$MetaInFolder" >>"$METAPACKAGES"
				((++count))
			done
		fi
		#		log_success_msg2 "  Updating... (${blue}${cstrvalue}${reset}) packages in ${Folders}"
		log_msg "Updating... ${red}$(strzero "$count" 5)${blue} packages in ${yellow}$Folders"
	done
	#	{ kill $SPINNERPID; wait $SPINNERPID 2>/dev/null; echo ;}

	#	LLIST=$true ; sh_recreatefilepackagesinstalled
	verbose=$oldverbose
	fn_pkgincache
	sh_cleaning
	unset FOLDER_TEMP

	nfilesInReposit=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_SPLIT")
	nfilesInstalled=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT")
	nfilesInCache=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE")
	log_msg "${pink}All list packages updated!"
	log_msg "${red}$(strzero "$nfilesInReposit" 5) ${bold}${green}packages in the repository"
	log_msg "${red}$(strzero "$nfilesInstalled" 5) ${bold}${green}installed packages"
	log_msg "${red}$(strzero "$nfilesInCache" 5) ${bold}${green}packages in cache $CACHEDIR_ARCHIVES"
	echo
	log_msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd >/dev/null 2>&- || return 1
}

fn_updateOLD() {
	local Folders
	local FoldersInRepo
	local PackagesInFolders
	local MetaPkgInFolders
	local MetaInFolder
	local cstrvalue
	local response
	local count
	local nfilesInReposit
	local nfilesInstalled
	local nfilesInCache
	local dw=("$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
		"$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES"
		"$CACHEDIR_SEARCH/$METAPACKAGES"
	)

	if ((LSELF)); then
		sh_selfupdate "$@"
		return $?
	fi

	#internet?
	sh_checknet || return 1

	if [[ response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "${SITE}/packages/") = "404" ]]; then
		log_failure_msg "${red}error${reset}: $response Not Found ${orange}==> $SITE/packages/"
		exit 1
	fi

	pushd "$CACHEDIR_SEARCH/" >/dev/null 2>&- || return 1
	sh_backup

	log_msg "${pink}Cleaning up ${CACHEDIR_SEARCH}/${reset}"
	for i in "${dw[@]}"; do
		printf '' >|"$i"
	done

	log_msg "${pink}Updating folders from ${SITE}"
	FoldersInRepo=$(lynx -listonly -nonumbers -dump -justify "${SITE}/packages/" | grep -Po '.*packages\/\K.*?(?=\/)')

	log_msg "${pink}Synchronizing package databases from ${SITE}${reset}"
	for Folders in ${FoldersInRepo[*]}; do
		FOLDER_TEMP="$TMP_DIR_FOLDERS/$Folders"
		if [[ response=$(curl --compressed -k -s -w "%{http_code}\n" --url "$SITE/packages/$Folders/" --output "$FOLDER_TEMP") = 404 ]]; then
			log_failure_msg "${red}error${reset}: $response Not Found ${orange}==> $SITE/packages/$Folders/"
			exit 1
		fi
		mapfile -t SizePkgInFolders <<<"$(sed -nE "s/$SED_RE/\9/p" "$FOLDER_TEMP")"

		if [[ "$Folders" != "meta" ]]; then
			#			PackagesInFolders=$(lynx -listonly -nonumbers -dump "$SITE/packages/$Folders/" |	grep File | awk '{print $2}')
			#			PackagesInFolders=$(lynx -listonly -nonumbers -dump "$SITE/packages/$Folders/" | grep -Po "$PKG_RE_LYNX")
			#			PackagesInFolders=($(wget "$SITE/packages/$Folders/" -qO - | grep -Po "$SED_RE"))
			#			PackagesInFolders=($(curl --compressed -k -s --url "$SITE/packages/$Folders/" | grep -Po "$SED_RE"))
			#ok		PackagesInFolders=($(curl --compressed -k -s --url "$SITE/packages/$Folders/" | sed -nE "s;$SED_RE;\1-\2-\5\6;p"))
			if ((CHILI_OS)); then
				mapfile -t PackagesInFolders <<<"$(sed -nE "s/$SED_RE/\1-\2-\5\6/p" "$FOLDER_TEMP")"
			else
				mapfile -t PackagesInFolders <<<"$(sed -nE "s/$SED_RE/\1-\2\6/p" "$FOLDER_TEMP")"
			fi
			count=0
			for pkgInFolder in "${PackagesInFolders[@]}"; do
				if [[ -n "$pkgInFolder" ]]; then
					sh_splitpkg "$pkgInFolder"
					pkg_size=$(human_to_bytes "${SizePkgInFolders[$count]}")
					echo "${aPKGSPLIT[$PKG_BASE]}$SEP${aPKGSPLIT[$PKG_VERSION]}$SEP${aPKGSPLIT[$PKG_BUILD]}$SEP${aPKGSPLIT[$PKG_FULLNAME]}$SEP${Folders}/${pkgInFolder}$SEP${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP${pkg_size}" >>$CACHEDIR_SEARCH/$PACKAGES_SPLIT
					((++count))
				fi
			done
		else
			MetaPkgInFolders=$(lynx -listonly -nonumbers -dump "$SITE/packages/$Folders/" | grep -Po '.*\/\K.*')
			count=0
			for MetaInFolder in "${MetaPkgInFolders[@]}"; do
				echo "${Folders}/${MetaInFolder}" >>"$FOLDERS_METAPACKAGES"
				echo "${MetaInFolder}" >>"$METAPACKAGES"
				((++count))
			done
		fi

		: <<'comment'
#		SizePkgInFolders=$(lynx -nonumbers -dump "$SITE/packages/$Folders/" | grep File | awk '{print $5}')
#		SizePkgInFolders=($(wget "$SITE/packages/$Folders/" -qO - | grep -Po "$SED_RE" | awk '{print $5*1024}'))
#		SizePkgInFolders=($(curl --compressed --insecure --silent --url "$SITE/packages/$Folders/" | grep -Po "$SED_RE" | awk '{print $5*1024}'))
#		SizePkgInFolders=($(wget "$SITE/packages/$Folders/" -qO - | sed -nE "s;$SED_RE;\3;p"))
#ok	SizePkgInFolders=($(curl --compressed --insecure --silent --url "$SITE/packages/$Folders/" | sed -nE "s;$SED_RE;\9;p"))
		mapfile -t SizePkgInFolders <<< "$(sed -nE "s/$SED_RE/\9/p" "$FOLDER_TEMP")"

		count=0
		if [[ $Folders != "meta" ]]; then
			for pkgInFolder in "${PackagesInFolders[@]}"; do
				if [[ -n "$pkgInFolder" ]]; then
					sh_splitpkg "$pkgInFolder"
					pkg_size=$(human_to_bytes "${SizePkgInFolders[$count]}")
					echo "${aPKGSPLIT[$PKG_BASE]}$SEP${aPKGSPLIT[$PKG_VERSION]}$SEP${aPKGSPLIT[$PKG_BUILD]}$SEP${aPKGSPLIT[$PKG_FULLNAME]}$SEP${Folders}/${pkgInFolder}$SEP${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP${pkg_size}" >> $CACHEDIR_SEARCH/$PACKAGES_SPLIT
					(( ++count ))
				fi
			done
		else
			for MetaInFolder in "${MetaPkgInFolders[@]}"; do
				echo "${Folders}/${MetaInFolder}" >> "$FOLDERS_METAPACKAGES"
				echo "${MetaInFolder}"            >> "$METAPACKAGES"
				(( ++count ))
			done
		fi
comment
		cstrvalue=$(strzero "$count" 5)
		log_success_msg2 "  Updating... (${blue}${cstrvalue}${reset}) packages in ${Folders}"
	done
	#	{ kill $SPINNERPID; wait $SPINNERPID 2>/dev/null; echo ;}

	#sh_recreatefilepackagesinstalled
	fn_pkgincache
	sh_cleaning
	unset FOLDER_TEMP

	nfilesInReposit=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_SPLIT")
	nfilesInstalled=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT")
	nfilesInCache=$(sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE")
	log_msg "${cyan}All list packages updated!${reset}"
	log_msg "${blue}($(strzero "$nfilesInReposit" 5)) packages in the repository${reset}"
	log_msg "${green}($(strzero "$nfilesInstalled" 5)) installed packages${reset}"
	log_msg "${green}($(strzero "$nfilesInCache" 5)) packages in cache $CACHEDIR_ARCHIVES${reset}"
	echo
	log_msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd >/dev/null 2>&- || return 1
}

fn_updateMazon() {
	local nfilesInReposit
	local nfilesInstalled
	local nfilesInCache
	local HTTP_SERVER
	local response
	local Folders
	local count
	local dw=("$CACHEDIR_SEARCH/$PACKAGES_SPLIT"
		"$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES"
		"$CACHEDIR_SEARCH/$METAPACKAGES"
	)

	if ((LSELF)); then
		sh_selfupdate "$@"
		return $?
	fi

	#internet?
	sh_checknet || return 1

	response=$(curl --compressed -s -w "%{http_code}\n" -o /dev/null -k --url "${SITE}/packages/")
	if [[ $response -eq 404 ]]; then
		log_failure_msg "${red}error${reset}: $response Not Found ${orange}==> $SITE/packages/"
		exit 1
	fi

	pushd "$CACHEDIR_SEARCH/" >/dev/null 2>&- || return 1
	sh_backup

	log_msg "${pink}Cleaning up ${CACHEDIR_SEARCH}/${reset}"
	for i in "${dw[@]}"; do
		printf '' >|"$i"
	done
	HTTP_SERVER="$(string_alltrim "$(curl --compressed -s -k --head -w '%{http_code}\n' --url "${SITE}" | grep '^[Ss]erver' | awk '{print $2}')" | cut -d/ -f1)"

	#debug "${HTTP_SERVER}"
	#debug "$(string_len "${HTTP_SERVER}")"
	log_msg "${pink}Updating folders from ${SITE}${reset}"
	case ${HTTP_SERVER} in
	Apache | nginx)
		FoldersInRepo=$(curl --compressed -k -s --url "${SITE}/packages/" | grep -Po '>[[:alnum:]]*/' | sed 's/>//g;s/\///g' | tee "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")
		;;
	LiteSpeed | cloudflare)
		FoldersInRepo=$(curl --compressed -k -s --url "${SITE}/packages/" | grep -Po 'packages\/[a-z]+' | sed 's/packages\///g' | tee "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")
		;;
	GitHub.com)
		FoldersInRepo=$(curl --compressed -k -s --url "$SITE/packages/" | grep /packages/ | sed 's/<[^>]*>//g;s/ //g' | tee "$CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES")
		;;
	esac

	log_msg "${pink}Synchronizing package databases from ${SITE}${reset}"
	#spinner & SPINNERPID=$!

	#	lynx --nonumbers -dump -justify http://localhost/packages/a/ | grep -Po '(?!.*\/)(.*)-(([^-]+)-([0-9]+))-([^.]+)(\.chi\.zst)'

	for Folders in ${FoldersInRepo}; do
		FOLDER_TEMP="$TMP_DIR_FOLDERS/$Folders"
		response=$(curl --compressed --insecure -s -w "%{http_code}\n" -k --url "$SITE/packages/$Folders/" --output "$FOLDER_TEMP")
		case ${HTTP_SERVER} in
		Apache | nginx)
			if [[ $Folders != "meta" ]]; then
				mapfile -t PackagesInFolders < <(grep -Eo '>'"$PKG_RE"'<' "$FOLDER_TEMP" | sed 's/>//g; s/<//g')
			else
				mapfile -t MetaPkgInFolders < <(grep -E '.meta\"' "$FOLDER_TEMP" | cut -d'"' -f2)
			fi
			mapfile -t SizePkgInFolders < <(grep -E "$GREP_RE" "$FOLDER_TEMP" | awk '{print $5}')
			;;
		LiteSpeed | GitHub.com | cloudflare)
			if [[ $Folders != "meta" ]]; then
				#					PackagesInFolders=$(curl --compressed --insecure --silent --url "${SITE}/packages/${Folders}/"|sed 's/^.*href="//' | sed 's/".*$//' | sed 's/\// /g' | grep ".${PKG_EXT}$"| awk '{print $NF}')
				#					PackagesInFolders=$(cat "$FOLDER_TEMP" | sed 's/^.*href="//' | sed 's/".*$//' | sed 's/\// /g' | grep -E ".${PKG_EXT}$"| awk '{print $NF}')
				PackagesInFolders=$(sed 's/^.*href="//' "$FOLDER_TEMP" | sed 's/".*$//' | sed 's/\// /g' | grep -E ".${PKG_EXT}$" | awk '{print $NF}')
			else
				#					MetaPkgInFolders=$(curl --compressed --insecure --silent --url "${SITE}/packages/${Folders}/" |sed 's/^.*href="//' | sed 's/".*$//' | sed 's/\// /g' | grep ".meta$" | awk '{print $NF}')
				#					MetaPkgInFolders=$(cat "$FOLDER_TEMP" | sed 's/^.*href="//' | sed 's/".*$//' | sed 's/\// /g' | grep -E ".meta$" | awk '{print $NF}')
				MetaPkgInFolders=$(sed 's/^.*href="//' "$FOLDER_TEMP" | sed 's/".*$//' | sed 's/\// /g' | grep -E ".meta$" | awk '{print $NF}')
			fi
			mapfile -t SizePkgInFolders < <(grep -E "$GREP_RE $FOLDER_TEMP" | awk '{print $9}' | cut -d'"' -f2)
			;;
		esac

		count=0
		if [[ $Folders != "meta" ]]; then
			for pkgInFolder in "${PackagesInFolders[@]}"; do
				sh_splitpkg "$pkgInFolder"
				pkg_size="${SizePkgInFolders[$count]}"
				echo "${aPKGSPLIT[$PKG_BASE]}$SEP${aPKGSPLIT[$PKG_VERSION]}$SEP${aPKGSPLIT[$PKG_BUILD]}$SEP${aPKGSPLIT[$PKG_FULLNAME]}$SEP${Folders}/${pkgInFolder}$SEP${aPKGSPLIT[$PKG_BASE_VERSION]}$SEP${pkg_size}" >>$CACHEDIR_SEARCH/$PACKAGES_SPLIT
				((count++))
			done
		else
			for MetaInFolder in "${MetaPkgInFolders[@]}"; do
				echo "${Folders}/${MetaInFolder}" >>$FOLDERS_METAPACKAGES
				echo "${MetaInFolder}" >>$METAPACKAGES
				((count++))
			done
		fi
		cstrvalue=$(strzero "$count" 5)
		log_success_msg2 "  Updating... (${blue}${cstrvalue}${reset}) packages in ${Folders}"
	done
	#	{ kill $SPINNERPID; wait $SPINNERPID 2>/dev/null; echo ;}

	#sh_recreatefilepackagesinstalled
	fn_pkgincache
	sh_cleaning
	unset FOLDER_TEMP

	nfilesInReposit=$(wc -l <$CACHEDIR_SEARCH/$PACKAGES_SPLIT)
	nfilesInstalled=$(wc -l <$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT)
	nfilesInCache=$(wc -l <$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE)
	log_msg "${cyan}All list packages updated!${reset}"
	log_msg "${blue}($(strzero "$nfilesInReposit" 5)) packages in the repository${reset}"
	log_msg "${green}($(strzero "$nfilesInstalled" 5)) installed packages${reset}"
	log_msg "${green}($(strzero "$nfilesInCache" 5)) packages in cache $CACHEDIR_ARCHIVES${reset}"
	echo
	log_msg "${reset}Use: # ${0##*/} --help for helping${reset}"
	popd >/dev/null 2>&- || return 1
}

sh_filesincache() {
	local -i nfilesincache
	local item
	local pkg_base
	local cline
	local aCacheFullname

	((verbose >= 2)) && log_msg "Recreating IN CACHE packages list"
	printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
	mapfile -t aCacheFullname < <(find "$CACHEDIR_ARCHIVES/" -iname "*.$PKG_EXT" -type f | sort)
	nfilesincache=${#aCacheFullname[*]}

	if ((nfilesincache)); then
		nfilesincache=0
		for item in ${aCacheFullname[*]}; do
			((++nfilesincache))
			sh_splitpkg "$item"
			pkg_base="${aPKGSPLIT[$PKG_BASE]}"
			aCache+=("$pkg_base")
			cline=$(clinesplit)
			echo "$cline" >>"$CACHEDIR_SEARCH/$PACKAGES_IN_CACHE"
			#			(( verbose >= 2 )) && sh_write "$pkg_base" "0" "$nfilesincache"
		done
	fi
	#	(( verbose >= 2 )) && printf "${yellow}(%05d) %s\n" "$nfilesincache" "${cyan}packages IN CACHE $CACHEDIR_ARCHIVES"
	return 0
}

# -Pi
fn_pkgincache() {
	local lfind=$false
	local nfilesoutcache=0
	local nfilesincache=0
	local aPkgOut
	local aPkgIn
	local x
	local y
	local indice=0

	((verbose >= 2)) && log_msg "Ok, let's do it..."
	((verbose >= 2)) && log_msg "Wait, doing some calculations..."
	sh_filesincache

	nfilesincache=${#aCache[*]}
	fn_writetable "${aCache[*]}" '0' $nfilesincache

	: <<'comment'
	for y in ${public_pkg_base[*]};do
		if ! ascan "$y" "${aCache[@]}"; then
			((++nfilesoutcache))
  		   aPkgOut+=("${public_pkg_base_version[$indice]}")
		else
			((++nfilesincache))
			(( verbose >= 2 )) && sh_write "$y" "0" "$nfilesincache"
			aPkgIn+=("${public_pkg_base_version[$indice]}")
		fi
		((++indice))
	done
	fn_writetable "${aPkgIn[*]}" '5' $nfilesincache
comment

	if ((verbose >= 2)); then
		printf "${yellow}(%05d) %s\n" "$nfilesincache" "${cyan}packages in cache"
		printf "${yellow}(%05d) %s\n" "$nfilesoutcache" "${cyan}packages OUT CACHE $CACHEDIR_ARCHIVES"
		printf "${yellow}(%05d) %s\n" "$public_len_count_pkg" "${cyan}packages in the repository${reset}"
	fi
	return 0
}

# -Po
sh_pkgoutcache() {
	local lfind=$false
	local nfilesoutcache=0
	local nfilesincache=0
	local aPkgOut
	local aPkgIn
	local x
	local y
	local indice=0

	((verbose >= 2)) && log_msg "Ok, let's do it..."
	((verbose >= 2)) && log_msg "Wait, doing some calculations..."
	sh_filesincache

	for y in ${public_pkg_base[*]}; do
		if ! ascan "$y" "${aCache[@]}"; then
			((++nfilesoutcache))
			((verbose >= 2)) && sh_write "$y" "0" "$nfilesoutcache"
			#			aPkgOut+=("$y")
			aPkgOut+=("${public_pkg_base_version[$indice]}")
		else
			((++nfilesincache))
			#			aPkgIn+=("$y")
			aPkgIn+=("${public_pkg_base_version[$indice]}")
		fi
		((++indice))
	done

	fn_writetable "${aPkgOut[*]}" '5' $nfilesoutcache

	if ((verbose >= 2)); then
		printf "${yellow}(%05d) %s\n" "$nfilesincache" "${cyan}packages in cache"
		printf "${yellow}(%05d) %s\n" "$nfilesoutcache" "${cyan}packages OUT CACHE $CACHEDIR_ARCHIVES"
		printf "${yellow}(%05d) %s\n" "$public_len_count_pkg" "${cyan}packages in the repository${reset}"
	fi
	return 0
}

sh_CatAndSizePkg() {
	local cpacote="$1"
	local LSHOW="$2"
	local lresult=$ERR_OK

	if [[ -e "$cpacote" ]]; then
		source "$cpacote"
		if ((LSHOW)); then
			printf '%s\n' "${cyan}BaseName     : ${yellow}${aPKGSPLIT[$PKG_FOLDER_DIR]}/${aPKGSPLIT[$PKG_FULLNAME]}"
			printf '%s\n' "${cyan}Name         : ${yellow}${pkgname}"
			printf '%s\n' "${cyan}Version      : ${yellow}${version}"
			printf '%s\n' "${cyan}Build        : ${yellow}${build}"
			printf '%s\n' "${cyan}Description  : ${yellow}${desc}"
			printf '%s\n' "${cyan}Architecture : ${yellow}${arch}"
			printf '%s\n' "${cyan}URL          : ${yellow}${url}"
			printf '%s\n' "${cyan}Licenses     : ${yellow}${license}"
			printf '%s\n' "${cyan}Dependencies : ${yellow}${depend}"
			printf '%s\n' "${cyan}Dependencies : ${yellow}${dep}"
			printf '%s\n' "${cyan}Size         : ${yellow}$(size_to_human "$size")"
			printf '%s\n' "${cyan}Packer       : ${yellow}${maintainer}"
			printf '%s\n' "${cyan}Distro       : ${yellow}${distro}"
			printf '%s\n' "${cyan}Init         : ${yellow}${lfs_init}"
			printf '%s\n' "${cyan}LSB          : ${yellow}${lfs_version}"
			printf '%s\n' "${reset}"
		fi
		unset pkgname version build desc arch url license depend dep size mainteiner distro lfs_init lfs_version
	else
		lresult=$ERR_ERROR
	fi
	return $lresult
}

sh_ShortCatPkg() {
	local cpacote="$1"
	local LSHOW=$2
	local lresult=$ERR_OK
	local cpackage="${aPKGSPLIT[$PKG_BASE]}"
	local SEARCH_CUT='-f5'
	local pkginstalled=

	if [[ -e "$cpacote" ]]; then
		source "$cpacote"
		if ((LSHOW)); then
			pkginstalled=$(grep ^"$cpackage$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" | cut -d"$SEP" "$SEARCH_CUT")
			if [[ -z "$pkginstalled" ]]; then
				printf "%s  %s %s\n" "${pink}${aPKGSPLIT[$PKG_FOLDER_DIR]}/${yellow}${aPKGSPLIT[$PKG_BASE]}" "${green}${aPKGSPLIT[$PKG_VERSION]}" "${white}${desc::40}"
			else
				printf "%s  %s %s\n" "${pink}${aPKGSPLIT[$PKG_FOLDER_DIR]}/${yellow}${aPKGSPLIT[$PKG_BASE]}" "${green}${aPKGSPLIT[$PKG_VERSION]}" "${cyan}[installed] ${white}${desc::40}"
			fi
			printf '%s' "${reset}"
		fi
		unset pkgname version desc arch url license depend dep size maintainer distro lfs_init lfs_version
	else
		lresult=$ERR_ERROR
	fi
	return $lresult
}

# -Qi
sh_show() {
	local param="$@"
	local saveverbose=$verbose
	local ntotal_pkg_listed
	local cpacote
	local lresult=$ERR_ERROR

	((verbose >= 2)) && log_msg "Reading package list..."
	verbose=0
	LDEPS=$false
	LEXACT=$true
	fn_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param"
	ntotal_pkg_listed="$public_ntotal_pkg_listed"
	verbose=$saveverbose

	if ((ntotal_pkg_listed)); then
		for i in ${public_pkg[*]}; do
			sh_splitpkg "$i"
			cpacote="$CACHEDIR_ARCHIVES/${aPKGSPLIT[1]}.desc"

			if ((LFORCE)) || ! [[ -e "$cpacote" ]]; then
				if ! sh_wgetdesc "$i"; then
					continue
				fi
			fi
			sh_CatAndSizePkg "$cpacote" $true
		done
		lresult=$ERR_OK
	fi
	return $lresult
}

# -Ss
sh_search() {
	local param="$@"
	local saveverbose=$verbose
	local ntotal_pkg_listed
	local cpacote
	local lresult=$ERR_ERROR

	((verbose >= 2)) && log_msg "Reading package list..."
	verbose=0
	LDEPS=$false
	#	LEXACT=$true
	fn_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param"
	ntotal_pkg_listed="$public_ntotal_pkg_listed"
	verbose=$saveverbose

	if ((ntotal_pkg_listed)); then
		for i in ${public_pkg[*]}; do
			sh_splitpkg "$i"
			cpacote="$CACHEDIR_ARCHIVES/${aPKGSPLIT[1]}.desc"

			if ((LFORCE)) || ! [[ -e "$cpacote" ]]; then
				if ! sh_wgetdesc "$i"; then
					continue
				fi
			fi
			sh_ShortCatPkg "$cpacote" $true
		done
		lresult=$ERR_OK
	fi
	return $lresult
}

# -R
sh_remove() {
	local param="$@"
	local x
	local cPkgFullFilename
	local ntotal_pkg_listed

	LDEPS=$false
	LEXACT=$true
	LREMOVE=$true
	fn_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" "$param"
	ntotal_pkg_listed="$public_ntotal_pkg_listed"

	if ((ntotal_pkg_listed)); then
		if ! ((LAUTO)); then
			echo
			confno "${blue}::${reset} Remove package(s)?"
			LAUTO=$?
		fi

		if ((LAUTO)); then
			for cPkgFullFilename in ${public_pkg[*]}; do
				sh_splitpkg "$cPkgFullFilename"
				sh_doremove "${aPKGSPLIT[$PKG_BASE_VERSION]}" "$cPkgFullFilename"
			done
		fi
	else
		echo
		#log_failure_msg2 "${red}error${reset}:${orange}${public_ListSearch} ${reset}not installed."
		return $ERR_ERROR
	fi
	return $ERR_OK
}

sh_doremove() {
	local cPkgBaseVersion="$1"
	local cPkgFullFilename="$2"

	log_wait_msg "Wait, Removing package ${orange}$cPkgFullFilename"
	if sh_removepkg "$cPkgBaseVersion" "$cPkgFullFilename"; then
		if ((LLIST)); then
			log_success_msg2 "${green}$cPkgFullFilename${reset} Done. Removal of the package successfully completed"
		fi
		return $ERR_OK
	fi
	return $ERR_ERROR
}

sh_removepkg() {
	local cPkgBaseVersion="$1"
	local cPkgFullFilename="$2"

	sh_pre_remove "$cPkgBaseVersion" || return $ERR_ERROR
	#	sh_splitpkg "$cPkgFullFilename"  || return $ERR_ERROR
	if sed -i '/'"$cPkgBaseVersion"'/d' "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"; then
		return $ERR_OK
	fi
	return $ERR_ERROR
}

sh_remove_now() {
	local cPkgBaseVersion="${1/%.${PKG_EXT}/}"
	local thefile

	pushd "/" >/dev/null 2>&- || return 1

	if [[ -e "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm" ]]; then
		sed -E "/rm[[:space:]]+\-(rf|fr)/d" "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm" >/dev/null 2>&-
		bash "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm"
		rm "${CACHEDIR_REMO}/${cPkgBaseVersion}.rm" >/dev/null 2>&-
	fi

	while IFS= read -r thefile; do
		if [[ -f "$thefile" ]]; then
			rm "$thefile" >/dev/null 2>&- && print "Delete\t${thefile}"
		fi
		if [[ -L "$thefile" ]]; then
			unlink "$thefile" >/dev/null 2>&-
		fi
		if [[ -d "$thefile" ]] && [[ -z "$(ls -A "$thefile")" ]]; then
			rmdir -p "${thefile}" >/dev/null 2>&-
		fi
	done <"${CACHEDIR_LIST}/${cPkgBaseVersion}.list"

	popd >/dev/null 2>&- || return 1
	IFS=$SAVEIFS

	if ! rm "$CACHEDIR_DESC/$cPkgBaseVersion.desc" >/dev/null 2>&-; then {
		log_failure_msg2 "Error, It was not possible remove $CACHEDIR_DESC/$cPkgBaseVersion.desc"
		return 1
	}; fi
	if ! rm "$CACHEDIR_LIST/$cPkgBaseVersion.list" >/dev/null 2>&-; then {
		log_failure_msg2 "Error, It was not possible remove $CACHEDIR_LIST/$cPkgBaseVersion.list"
		return 1
	}; fi
	return $ERR_OK
}

sh_pre_remove() {
	local cPkgBaseVersion="$1"
	local cExtList="$cPkgBaseVersion.list"

	if [[ -e "$CACHEDIR_LIST/$cExtList" ]]; then
		sh_remove_now "$cPkgBaseVersion"
		return $ERR_OK
	else
		log_failure_msg2 "Error, file not found: ${red}$CACHEDIR_LIST/$cExtList"
		return $ERR_ERROR
	fi
	fn_subshell_status
}

sh_pre_removeOLD() {
	(
		local cPkgBaseVersion="$1"
		local nlenstrpkg=${#cPkgBaseVersion}
		local pkgsearch="${cPkgBaseVersion:0:$((nlenstrpkg - 2))}"
		local re="\b${pkgsearch}\b"
		local inc=0
		local count_occurrences=0
		local search_pack
		local name_version_build
		local q
		local alldesc=$cPkgBaseVersion.desc

		pushd "$CACHEDIR_DESC" >/dev/null 2>&- || return 1
		for search_pack in $alldesc; do
			if [[ "$search_pack" =~ ^${re}.* ]]; then
				for q in *; do
					if [[ "$q" =~ ^${re}.* ]]; then
						((count_occurrences++))
					fi
				done

				[[ -e "$CACHEDIR_DESC/$search_pack" ]] && source "$CACHEDIR_DESC/$search_pack"
				name_version_build="$cPkgBaseVersion"
				pushd "${CACHEDIR_LIST}" >/dev/null 2>&- || return 1
				search_pack="${search_pack/%.desc/.list}" # se terminar com .desc substitua por .list
				#			[[ -e "${search_pack}" ]] && { sh_remove_now "$name_version_build"; return 0 ;} || { log_failure_msg2 "ERROR: FILE NOT FOUND ${CACHEDIR_LIST}/${search_pack}"; return 1;}
				if [[ -e "${search_pack}" ]]; then
					sh_remove_now "$name_version_build"
					return 0
				else
					log_failure_msg2 "ERROR: FILE NOT FOUND ${CACHEDIR_LIST}/${search_pack}"
					return 1
				fi
				continue
			else
				((inc++))
			fi
		done

		[[ $inc -gt 0 ]] && {
			log_failure_msg2 "NOT FOUND ${cPkgBaseVersion}"
			return 1
		}
	)
	fn_subshell_status
}

sh_download() {
	local param="$@"
	local error_value=0
	local nFilesDownloaded=0

	LDEPS=$false
	LEXACT=$true
	fn_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param"
	local ntotal_pkg_listed="${public_ntotal_pkg_listed}"

	if [[ $public_pkg != "" ]]; then
		pushd "$CACHEDIR_ARCHIVES/" >/dev/null 2>&- || return 1
		#internet?
		sh_checknet || return 1

		if ((verbose)); then
			log_msg "Downloading package..."
		fi

		for i in $public_pkg; do
			sh_splitpkg "$i"
			local cfullname="${aPKGSPLIT[$PKG_FULLNAME]}"

			if ((LFORCE)); then
				sh_wgetdesc "$i"
				if sh_wgetfull "$i"; then
					((nFilesDownloaded++))
				fi
			else
				if test -e "$CACHEDIR_ARCHIVES/$cfullname"; then
					log_failure_msg2 "${orange}${i##*/} ${reset}Package is already downloaded. Use the -f option to force download."
				else
					sh_wgetdesc "$i"
					if sh_wgetfull "$i"; then
						((nFilesDownloaded++))
					fi
				fi
			fi
		done
		log_msg "${cyan}($nFilesDownloaded) packages(s) downloaded."
		popd >/dev/null 2>&- || return 1
	fi
}

fn_sanitize_deps() {
	local arr=("${@:1}")
	local cdep

	for i in ${arr[*]}; do
		cdep="${i%%=*}"
		cdep="${cdep%%.so*}"
		cdep="${cdep#lib}"
	done
	return 0
}

sh_getdeps() {
	local ncontadep=0
	local arr
	local pkgNumber=0
	local cfullfilename
	local x
	local LDEPS=$1
	local ndep

	GETDEPS=()
	deps=()

	((verbose >= 2)) && log_msg "Solving dependencies"

	for i in ${public_pkg[*]}; do
		sh_splitpkg "$i"
		cbase="${aPKGSPLIT[PKG_BASE]}"
		cfullfilename="${aPKGSPLIT[PKG_FULLNAME]}"
		[[ -e "$CACHEDIR_ARCHIVES/$cfullfilename.desc" ]] || sh_wgetdesc || return 1
		source "$CACHEDIR_ARCHIVES/$cfullfilename.desc"
		if ((LDEPS)); then
			deps+=(${dep[*]})
			deps+=($(grep ^depend "$CACHEDIR_ARCHIVES/$cfullfilename.desc" | awk -F"'" '{print $2}'))
		fi
	done

	#sanitize deps
	deps=($(sh_adel ${deps[*]}))
	adeps=${deps[*]}
	deps=()

	for i in ${adeps[*]}; do
		cdep="${i%%=*}"
		cdep="${cdep%%.so*}"
		cdep="${cdep%%>=*}"
		cdep=$(grep -Po '^([a-z]+[-|_]?[a-z]+)' <<<"$i")

		if ! sh_ascanpkg "$cdep" "0"; then
			cdep="${cdep#lib}"
			if ! sh_ascanpkg "$cdep" "0"; then
				continue
			fi
		fi
		deps+=("$cdep")
	done
	deps=($(sh_adel ${deps[*]}))

	for i in ${deps[*]}; do
		((++ncontadep))
		pkgdep=$(grep ^"$i$SEP" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | awk -F"$SEP" '{print $5}')
		if [[ -z "$pkgdep" ]]; then
			if ((verbose)); then
				printf "${red}%s(%04d) ${orange}%-40s ${reset}%-40s\n" "     " "$ncontadep" "${i}" "WARNING! Dependency not found in the database. ${reset}Use: # fetch -Syy to update with the repository${reset}"
			fi
		else
			GETDEPS+=("$pkgdep")
			pkginstalled=$(grep ^"$i$SEP" "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" | awk -F"$SEP" '{print $5}')
			#	  		if [[ -z "$pkginstalled" ]]; then
			#				#GETDEPS+=("$pkgdep")
			#				echo
			#	  		fi
		fi
	done
	# 	public_pkg_deps+=$GETDEPS
	public_pkg_deps+=${GETDEPS[*]}
	return $?
}

sh_splitpkg() {
	file=$1
	aPKGSPLIT=()
	pkg_folder_dir=${file%/*} #remove arquivo deixando somente o diretorio/repo
	pkg_fullname=${file##*/}  #remove diretorio deixando somente nome do pacote

	[[ "$pkg_folder_dir" == "$pkg_fullname" ]] && pkg_folder_dir="localhost"
	if [[ "$pkg_fullname" =~ $PKG_RE ]]; then
		pkg_fullname="${BASH_REMATCH[0]}"
		pkg_base="${BASH_REMATCH[1]}"
		pkg_version_build="${BASH_REMATCH[2]}"
		pkg_version="${BASH_REMATCH[3]}"
		pkg_build="${BASH_REMATCH[4]}"
		pkg_arch="${BASH_REMATCH[5]}"
		pkg_base_version="${pkg_base}-${pkg_version_build}"

		#debug "$pkg_base \n $pkg_version_build \n $pkg_version \n $pkg_build \n $pkg_arch \n $pkg_base_version \n"
		: <<'comment'
		  debug " file            : $file\n" \
		        "pkg_folder_dir  : $pkg_folder_dir\n" \
			 	  "pkg_fullname    : $pkg_fullname\n" \
			 	  "pkg_arch        : $pkg_arch\n" \
			 	  "pkg_base        : $pkg_base\n" \
				  "pkg_base_version: $pkg_base_version\n" \
				  "pkg_version     : $pkg_version\n" \
				  "pkg_build       : $pkg_build"
comment
		aPKGSPLIT=("$pkg_folder_dir"
			"$pkg_fullname"
			"$pkg_arch"
			"$pkg_base"
			"$pkg_base_version"
			"$pkg_version-$pkg_build"
			"$pkg_build"
		)
		return 0
	fi
	return 1
}

sh_splitpkgIFS() {
	local file=$1
	local pkg_folder_dir
	local pkg_fullname
	local pkg_arch
	local pkg_base
	local pkg_base_version
	local pkg_version
	local pkg_build
	local pkg_str
	local nconta=0
	local char='-'
	local var
	local re

	aPKGSPLIT=()
	pkg_folder_dir="${file%/*}"             #remove arquivo deixando somente o diretorio/repo
	pkg_fullname="${file##*/}"              #remove diretorio deixando somente nome do pacote
	pkg_arch="${pkg_fullname%."$PKG_EXT"*}" #remove extensao pacote (chi.zst/mz)
	pkg_arch="${pkg_arch%.arch1*}"          #remove extensao pacote (chi.zst/mz)
	pkg_arch="${pkg_arch##*-}"              #remove do começo até o ultimo -

	pkg_str="${pkg_fullname%-any."$PKG_EXT"*}" #remove extensao pacote (chi.zst/mz)
	pkg_str="${pkg_str%."$PKG_EXT"*}"          #remove extensao pacote (chi.zst/mz)
	pkg_str="${pkg_str%-x86_64*}"              #remove extensao pacote (chi.zst/mz)
	pkg_str="${pkg_str%."$PKG_EXT"*}"          #remove extensao pacote (chi.zst/mz)

	IFS='-'
	read -ra ADDR <<<"$pkg_str" # str is read into an array as tokens separated by IFS
	for var in "${ADDR[@]}"; do # access each element of array
		re='^[a-zA-Z]'
		if [[ "$var" =~ $re ]]; then
			pkg_base="$pkg_base${var}$char"
		else
			((nconta++))
			[[ $nconta -eq 1 ]] && pkg_version=$var || pkg_build=$var
		fi
	done
	IFS=$SAVEIFS
	pkg_base=${pkg_base%-*}
	pkg_base_version="${pkg_base}-${pkg_version}-${pkg_build}"
	[[ $pkg_folder = "" ]] && pkg_folder=$pkg_fullname

	aPKGSPLIT=("$pkg_folder_dir"
		"$pkg_fullname"
		"$pkg_arch"
		"$pkg_base"
		"$pkg_base_version"
		"$pkg_version-$pkg_build"
		"$pkg_build"
	)

	#	aPKGLIST=${aPKGSPLIT[*]}
	#	arr=(${aPKGSPLIT[*]})
	return $?
}

sh_splitpkgawk() {
	file=$1
	aPKGSPLIT=()

	pkg_folder_dir="${file%/*}" #remove arquivo deixando somente o diretorio/repo
	pkg_fullname="${file##*/}"  #remove diretorio deixando somente nome do pacote

	#	arr=($(echo "$pkg_fullname" | awk 'match($0, /(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst/, array) {
	#			print array[0]
	#			print array[1]
	#			print array[2]
	#		   print array[3]
	#		   print array[4]
	#   		print array[5]
	#    		print array[6]
	#			}'))
	mapfile -t arr < <(echo "$pkg_fullname" | awk 'match($0, /(.+)-(([^-]+)-([0-9]+))-([^.]+)\.chi\.zst/, array) {
			print array[0]
			print array[1]
			print array[2]
		   print array[3]
		   print array[4]
    		print array[5]
    		print array[6]
			}')

	pkg_fullname="${arr[0]}"
	pkg_base="${arr[1]}"
	pkg_version_build="${arr[2]}"
	pkg_version="${arr[3]}"
	pkg_build="${arr[4]}"
	pkg_arch="${arr[5]}"
	pkg_base_version="${arr[0]}-${arr[4]}"

	aPKGSPLIT=("$pkg_folder_dir"
		"$pkg_fullname"
		"$pkg_arch"
		"$pkg_base"
		"$pkg_base_version"
		"$pkg_version-$pkg_build"
		"$pkg_build"
	)
	return $?
}

# -S
sh_install() {
	local param="$@"
	local loldverbose=$verbose
	local ntotal_pkg_listed=0

	#	verbose=2
	SPLITPOS='4'
	LTABLE=$true
	LEXACT=$true
	fn_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param" || return 1
	ntotal_pkg_listed=$public_ntotal_pkg_listed
	verbose=$loldverbose

	if ((ntotal_pkg_listed)); then
		[[ -d $CACHEDIR_ARCHIVES/ ]] || mkdir -p "$CACHEDIR_ARCHIVES/"
		cd "$CACHEDIR_ARCHIVES/" || return 1

		if ! ((LAUTO)); then
			#		echo
			read -r -e -p "${blue}:: ${reset}Continue installation? [Y/n]" LDOWNLOAD
			if [[ $(toupper "${LDOWNLOAD}") = "N" ]]; then
				return
			fi
		fi
		sh_installdownload || return 1
		sh_installdoinstallpkg
	fi
	sh_cdroot
}

sh_installdownload() {
	local cfullfilename
	local cpacote
	local cpacotebase

	sh_checknet || return 1
	for i in ${public_pkg[*]}; do
		sh_splitpkg "$i"
		cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
		cpacote=${aPKGSPLIT[PKG_FULLNAME]}
		cpacotebase=${aPKGSPLIT[PKG_BASE]}

		[[ -e "$CACHEDIR_ARCHIVES/$cpacote" ]] || sh_wgetpartial "$i"
		local error_value=$?

		if [ ${error_value} -ne 0 ]; then
			log_failure_msg2 "ERROR: Downloading ${orange}${cfullfilename}"
			log_wait_msg "Restarting download ${orange}${cfullfilename}"
			sh_wgetfull
			local error_value=$?
			if [ ${error_value} -ne 0 ]; then
				log_failure_msg2 "ERROR: Fatal error downloading ${orange}${cfullfilename}. ${reset}"
				exit 1
			fi
		fi
	done
}

sh_wgetpartial() {
	local cfullfilename="$1"
	local cRaw

	[[ -z "$cpacote" ]] && cpacote="${cfullfilename##*/}"
	((GITSITE)) && cRaw="$RAW" || cRaw="$SITE"

	sh_wgetresponse "$i.desc" || return 1
	sh_wgetresponse "$i" || return 1
}

sh_wgetresponse() {
	local i="$1"
	local cfile="${i##*/}"
	local cfullfilename="$CACHEDIR_ARCHIVES/$cfile"
	local lresult
	export response

	sh_checknet || return 1
	((verbose >= 2)) && log_info_msg "${DOT}${cyan}Fetching package ${cRaw}/packages/${orange}${i}"
	response=$(curl -s -w "%{http_code}\n" -k -O "${cRaw}/packages/$i")
	lresult=$?
	((verbose >= 2)) && evaluate_retval $lresult

	if ! [[ $response -eq 200 ]]; then
		rm -f "$cfullfilename" >/dev/null 2>&-
		if ! ((LSKIPERROR)); then
			log_failure_msg "${red}error${reset}: $response NOT FOUND file ${orange}${cfile} ${reset}at $SITE/packages/ - Use the ${yellow}--skiperror ${reset}option to skip install."
		else
			log_failure_msg2 "${red}error${reset}: $response NOT FOUND file ${orange}${cfile} ${reset}at $SITE/packages/"
		fi
		return 1
	fi
	return 0
}

sh_wgetdesc() {
	local cfullfilename="$1"
	local cRaw
	local nretval=1

	if ! ((GITSITE)); then
		cRaw=$SITE #site normal
	else
		cRaw=$RAW #github
	fi
	pushd "$CACHEDIR_ARCHIVES/" >/dev/null 2>&-
	sh_wgetresponse "$i.desc"
	nretval=$?
	popd >/dev/null 2>&-
	return $nretval
}

sh_wgetfull() {
	local cfullfilename="$1"
	local cRaw
	local nretval

	if ! ((GITSITE)); then
		cRaw="$SITE" #site normal
	else
		cRaw="$RAW" #github
	fi
	sh_wgetresponse "$i"
	nretval=$?
	return $nretval
}

sh_installdoinstallpkg() {
	local LINSTALLED=$false
	local cpacoteinstalled

	for i in ${public_pkg[*]}; do
		sh_splitpkg "$i"
		local cfullfilename=${aPKGSPLIT[PKG_FULLNAME]}
		local cpacote=${aPKGSPLIT[PKG_FULLNAME]}
		local cpacotebase=${aPKGSPLIT[PKG_BASE]}
		local cBaseVersion=${aPKGSPLIT[$PKG_BASE_VERSION]}

		case "$cpacotebase" in
		gcc)
			log_failure_msg2 "Skipping package: $cpacotebase"
			continue
			;;
		gcc-libs)
			log_failure_msg2 "Skipping package: $cpacotebase"
			continue
			;;
		glibc)
			log_failure_msg2 "Skipping package: $cpacotebase"
			continue
			;;
		file)
			log_failure_msg2 "Skipping package: $cpacotebase"
			continue
			;;
		flac)
			log_failure_msg2 "Skipping package: $cpacotebase"
			continue
			;;
		esac

		cpacoteinstalled=$(grep ^"$cpacotebase$SEP" "${CACHEDIR_SEARCH}/$PACKAGES_INSTALLED_SPLIT" | cut -d"$SEP" -f6)
		[[ "$cpacoteinstalled" == "$cBaseVersion" ]] && LINSTALLED=$true || LINSTALLED=$false
		if ((LINSTALLED)) && ! ((LFORCE)); then
			log_failure_msg2 "${orange}${cBaseVersion} ${reset}Package is already installed. Use the -f option to force reinstallation."
			continue
		fi
		sh_installpkg "$cpacote"
		local error_value=$?
		if ! ((error_value)); then
			log_success_msg2 "${green}${cpacote} ${reset}Done. package installation successfully."
		fi
	done
}

sh_listmeta() {
	local param="$@"
	local cListSearch=$param
	local x
	local arr
	public_ntotal_pkg_meta=0

	LLIST=$true
	if ((verbose >= 2)); then
		log_msg "Reading meta package lists in the repository..."
	fi

	if ((LALL)) || [[ -z "$cListSearch" ]]; then
		if ((LALL)); then
			metapkg=$(cat $CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES)
		else
			log_failure_msg2 "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
			exit 1
		fi
	else
		for x in $cListSearch; do
			if ((LEXACT)); then
				cfile="$(grep "\/$x.meta$" $CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES)"
			else
				cfile="$(grep "$x" $CACHEDIR_SEARCH/$FOLDERS_METAPACKAGES)"
			fi
			metapkg+="$cfile"

			if [[ -z $cfile ]]; then
				if ! ((LSKIPERROR)); then
					log_failure_msg "${red}error${reset}: ${orange}${x} ${reset}target was ${red}NOT ${reset}found. Use the ${yellow}--skiperror ${reset}option to force install. "
					exit 1
				else
					log_failure_msg "${red}error${reset}: ${orange}${x} ${reset}target was ${red}NOT ${reset}found. ${yellow}Skipping"
				fi
			fi
		done
	fi

	arr=("${metapkg[*]}")
	public_ntotal_pkg_meta=${#arr[*]}

	if ((public_ntotal_pkg_meta)); then
		if ((verbose >= 2)); then
			log_msg "Listing... Done"
		fi
		for i in $metapkg; do
			((LLIST)) && log_success_msg2 "${blue}FOUND ${orange}$i"
		done
		((LLIST)) && log_success_msg2 "($public_ntotal_pkg_meta) meta package(s) found."
	else
		log_failure_msg2 "${red}error: ${reset}target not found : ${orange}${param}"
	fi
	return "$public_ntotal_pkg_meta"
}

sh_installmeta() {
	local param="$@"
	local pkgInMeta=()
	local cmetapackage

	sh_listmeta "$param"
	public_ntotal_pkg_meta=$?

	if ((public_ntotal_pkg_meta)); then
		if ! ((LAUTO)); then
			echo
			read -e -p -r "$(DOT)continue installation? [Y/n]" LDOWNLOAD
			if [[ $(toupper "${LDOWNLOAD}") = "N" ]]; then
				return
			fi
			LAUTO=$true
		fi

		pushd "$CACHEDIR_ARCHIVES/" >/dev/null 2>&- || return 1
		for cmetafile in $metapkg; do
			cmetapackage=$(echo "$cmetafile" | cut -d/ -f2)

			if ! ((GITSITE)); then
				curl --silent -k -O "$SITE/packages/$cmetafile"
			else
				curl --silent -k -O "$RAW/packages/$cmetafile"
			fi
			pkgInMeta+=("$(cat "$CACHEDIR_ARCHIVES/$cmetapackage")")
		done

		popd >/dev/null 2>&- || return 1
		param="$pkgInMeta"

		#		[[ $verbose -eq 0 ]] && (( verbose=1 ))
		verbose=0
		fn_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" "$param"
		local ntotal_pkg_listed=${public_ntotal_pkg_listed}

		if [[ $public_pkg != "" ]]; then
			[[ -d "$CACHEDIR_ARCHIVES/" ]] || mkdir -p "$CACHEDIR_ARCHIVES/"
			cd "$CACHEDIR_ARCHIVES/" || return 1

			if ! ((LAUTO)); then
				echo
				read -e -p -r "${blue}:: ${reset}Continue installation? [Y/n]" LDOWNLOAD
				if [[ $(toupper "${LDOWNLOAD}") = "N" ]]; then
					return
				fi
			fi
			sh_installdownload
			sh_installdoinstallpkg
		fi
		sh_cdroot
	fi
}

sh_recreateFilesFromArch() {
	local item
	local nfiles
	local aCache

	((verbose >= 2)) && log_msg "Fixing packages installed by pacman"
	pushd "/var/lib/pacman/local/" >/dev/null 2>&- || return 1
	mapfile -t aCache < <(printf '%s\n' *)
	nfiles=$(lenarray "${aCache[*]}")
	popd >/dev/null 2>&- || return 1

	if ((nfiles)); then
		for item in $aCache; do
			[[ "$item" == "ALPM_DB_VERSION" || $item == ',,,,' || -z $item ]] && continue
			[[ -f "$CACHEDIR_DESC/$item.desc" ]] || printf '' >|"$CACHEDIR_DESC/$item.desc"
		done
		return 0
	fi
	return 1
}

# -Sr
sh_recreatefilepackagesinstalled() {
	local re='(.+)-(([^-]+)-([0-9]))+[.](desc)$'
	local item
	local package
	local pkgNumber=0
	local nfiles
	local aCache
	local lresult=1

	((LLIST)) && log_msg "Recreating installed packages list"
	sh_recreateFilesFromArch

	((LLIST)) && log_msg "Reading lists of installed packages"

	printf '' >|"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	mapfile -t aCache < <(printf '%s\n' $CACHEDIR_DESC/* | awk -F "$re" 'list[$1]++')
	#2	aCache=$(grep -Po "$re" < <(printf '%s\n' $CACHEDIR_DESC/*) )
	#1	aCache=$(find $CACHEDIR_DESC/ -regextype posix-egrep -regex "$re" -type f | sort -V)
	nfiles=$(lenarray "${aCache[*]}")

	if ((nfiles)); then
		((LLIST)) && log_msg "Checking installed packages"
		#sh_arraypkgfull
		((verbose >= 2)) && sh_cabec "$nfiles"

		for item in ${aCache[*]}; do
			[[ -z "$item" ]] && continue
			package=${item##*/}
			package=${package%.desc*}
			clisting='N'
			((verbose >= 2)) && clisting=''
			if sh_ascanpkg "$package" '5'; then
				if sh_write "$package" '-1' $((++pkgNumber)) '' "$clisting"; then
					echo "$(clineascan)" >>"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
				fi
			fi
		done
		lresult=0
	fi
	log_msg "${yellow}($pkgNumber) ${cyan}packages installed - (use -Sr --verbose for listing)"
	return $lresult
}

# -Qq
sh_totalpackagesinstalled() {
	if ((verbose >= 2)); then
		awk -F "," '{print $1}' "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	else
		sh_linecount "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	fi
}

sh_listforinstall() {
	local param="$@"
	local pkgNumber=0
	local s
	local LLIST=$true
	local LEXACT=$false
	local LALL=$false
	local LDEPS=$true
	local ncontapkg=0
	local cListSearch
	local arr

	[[ -e $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT ]] || printf '' >"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
	public_ntotal_pkg_installed=$(sh_linecount $CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT)
	public_ntotal_pkg_listed=$public_ntotal_pkg_installed
	public_pkg=

	for s in "${param[@]}"; do
		cListSearch+="$s "
	done

	if ((LALL)) || [[ -z "$cListSearch" ]]; then
		if ((LALL)); then
			public_pkg=$(grep ^ $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f5)
		else
			log_failure_msg2 "${red}error${reset}: nenhum alvo definido (use -h para obter ajuda)"
			exit 1
		fi
	else
		for x in $cListSearch; do
			if ((LEXACT)); then
				if [[ "$SPLITPOS" == "0" ]]; then
					public_pkg="$public_pkg $(grep ^"$x": $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f1)"
				else
					public_pkg="$public_pkg $(grep ^"$x": $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f5)"
				fi
			else
				if [[ "$SPLITPOS" == "0" ]]; then
					public_pkg="$public_pkg $(grep "$x" $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f1)"
				else
					public_pkg="$public_pkg $(grep "$x" $CACHEDIR_SEARCH/$PACKAGES_SPLIT | cut -d$SEP -f5)"
				fi
			fi
		done
	fi

	if ((LLIST)); then
		arr=("${public_pkg[*]}")
		ncontapkg=${#arr[*]}
		if [[ "${#public_pkg}" -gt 0 ]]; then # pacote?
			pkgNumber=0
			sh_getdeps $LDEPS
			arr=("${public_pkg[*]}")
			ncontapkg=${#arr[*]}
			public_ntotal_pkg_listed=$ncontapkg
		else
			log_msg "($pkgNumber) package(s) found."
			echo
			echo -e "${reset}Use: # ${APP} -Sy - to update with the repository${reset}"
		fi
	else
		pkgNumber=0
		for i in $public_pkg; do
			((pkgNumber++))
		done
		public_ntotal_pkg_listed="$pkgNumber"
	fi
	sh_cdroot
	return $pkgNumber
}

sh_list_archives_directories() {
	local packname="${1}.list"
	local LIST_CLEAN_DIRECTORIES

	sed -i "
        s/^\.\///g
        s/^\///g
        s|\/$||g
        /^\./d
        /^ *$/d
        /^bin$/d
        /^info$/d
        /^boot$/d
        /^dev$/d
        /^etc$/d
        /^home$/d
        /^lib$/d
        /^lib64$/d
        /^media$/d
        /^mnt$/d
        /^opt$/d
        /^proc$/d
        /^root$/d
        /^run$/d
        /^sbin$/d
        /^srv$/d
        /^sys$/d
        /^tmp$/d
        /^usr$/d
        /^var$/d
        /^info\/pos\.sh$/d
        /^info\/pre\.sh$/d
        /^info\/desc/d
        /info\/rm.sh/d
        /^var\/lib\/banana\/list\/.*\.list/d
        /^var\/lib$/d
        /^var\/lib\/banana/d
        /^var\/lib\/banana\/list/d
        /^var\/lib\/banana\/remove/d
	" "${CACHEDIR_LIST}/${packname}"

	LIST_CLEAN_DIRECTORIES=(
		'var'
		'lib'
		'media'
		'usr'
		'usr/share'
		'srv'
	)

	while read -r view; do
		if [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[0]}/(cache|lib|local|lock|log|mail|opt|run|spool|tmp)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[1]}/(lib64)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[2]}/(cdrom|floppy)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[3]}/(bin|etc|lib|lib\/(pkgconfig)|local|share|doc|include|libexec|sbin|src)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[4]}/(keymaps|fonts|pixmaps|applications|doc|man|man\/man[[:digit:]]+|man\/.{2})$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^$view$/d" "${CACHEDIR_LIST}/${packname}"
		elif [[ "$view" =~ ^${LIST_CLEAN_DIRECTORIES[5]}/(www|httpd)$ ]]; then
			local view="${view//\//\\/}"
			sed -i "/^${view}$/d" "${CACHEDIR_LIST}/${packname}"
		fi
	done <"$CACHEDIR_LIST/$packname"
}

fn_subshell_status() {
	[[ "$?" -ne '0' ]] && return 1 || return 0
}

sh_manage_scripts_and_archives() {

	#	sh_splitpkg "${1}"
	local packname=${aPKGSPLIT[$PKG_BASE_VERSION]}
	local dir_desc="${CACHEDIR_LIST/list/desc}"

	if ! [[ -e "/tmp/info/desc" ]]; then
		log_failure_msg2 "ERROR! /info/desc does not exist. ABORT!"
		return 1
	fi

	pushd "/tmp/info/" >/dev/null 2>&- || return 1
	if ! mv '/tmp/info/desc' "$CACHEDIR_DESC/${packname}.desc"; then
		log_failure_msg2 "ERROR! could not move desc to /${dir_desc}/${packname}.desc"
		return 1
	fi

	if [[ -e "/tmp/info/pos.sh" ]]; then
		log_msg "running pos.sh hook"
		bash "/tmp/info/pos.sh"
	fi

	if [[ -e "/tmp/info/.INSTALL" ]]; then
		source /tmp/info/.INSTALL >/dev/null 2>&-
		log_msg "running post_install hook"
		post_install >/dev/null 2>&-
		log_msg "running post_upgrade hook"
		post_upgrade >/dev/null 2>&-
	fi

	if [[ -e "/tmp/info/rm.sh" ]]; then
		if ! mv '/tmp/info/rm.sh' "$CACHEDIR_REMO/${packname}.rm"; then
			log_failure_msg2 "ERROR! could not move rm.sh to $CACHEDIR_REMO/${packname}.rm"
			return 1
		fi
	fi

	popd >/dev/null 2>&- || return 1
	[[ -d "/info/" ]] && rm -r "/info/"
	[[ -d '/tmp/info/' ]] && rm -r "/tmp/info/"
	[[ -e '/.BUILDINFO' ]] && rm "/.BUILDINFO"
	[[ -e '/.MTREE' ]] && rm "/.MTREE"
	[[ -e '/.PKGINFO' ]] && rm "/.PKGINFO"
	[[ -e '/.INSTALL' ]] && rm "/.INSTALL"
	return 0
}

sh_create_list() {
	local packname="$1"

	if ! tar --use-compress-program=zstd --force-local --list --file "$packname" >"${CACHEDIR_LIST}/${name_version_build}.list"; then
		log_failure_msg2 "ERROR! Can not create ${CACHEDIR_LIST}/${name_version_build}.list"
		return 1
	fi
	return 0
}

sh_input_null_parameter() {
	pkg="$1"

	local arr
	if [[ -z "$pkg" ]]; then
		pkg=$(echo "$PWD" | sed 's/\// /g' | awk '{print $NF}' | sed 's/-/_/g' | sed 's/\(.*\)_/\1 /' | sed 's/ /-/g')
		arr=("$pkg")
		[[ ${#arr[*]} -gt 2 ]] && pkg="${arr[0]}_${arr[1]} ${arr[2]}"
		pkg=${pkg}-${DESC_BUILD}
	fi
	sh_info "INPUT_NULL" "$pkg"
	return 0
}

fn_name_format_pkg() {
	local packname="$1"

	re="\b${PKG_EXT}\b"
	if ! [[ "$packname" =~ .*\.${re}$ ]]; then
		log_failure_msg2 "ERROR Package need finish .${PKG_EXT}"
		return 1
	fi
	return 0
}

fn_generate_desc() {
	local i
	local DESC_PACKNAME=$1
	local DESC_VERSION=$2
	local DESC_BUILD=$3
	local field_pkgver=$4
	local field_pkgrel=$5
	#DESC=$(echo "${DESC//\'}") 		# remove apostrofe. ex: let´s => lets
	DESC=${DESC//\'/} # remove apostrofe. ex: let´s => lets

	[[ ! -d "info" ]] && mkdir info >/dev/null 2>&-

	if [ -e info/desc ]; then
		((ncount++))
		if ! ((LFORCE)); then
			if ((verbose >= 2)); then
				log_msg "$(fmt)${orange} info/desc ${reset}already exist. Skipping... Use the -f option to force recreate."
			fi
			return
		else
			if ((verbose >= 2)); then
				log_msg "$(fmt)${orange} info/desc ${reset}already exist. Rewriting"
			fi
		fi
	fi
	[[ -z "$SIZE" ]] && SIZE=$(sizeof_du .)

	cat >"info/desc" <<EOF
######################################################################
# Generated with fetch    - https://chililinux.com
# Generated with alienpkg - https://chililinux.com
######################################################################
maintainer='$MAINTAINER'
pkgname='$DESC_PACKNAME'
version='$DESC_VERSION'
build='$DESC_BUILD'
pkgver='$field_pkgver'
pkgrel='$field_pkgrel'
license='$LICENSE'
lfs_version='$LFS_VERSION'
lfs_init='$LFS_INIT'
arch='$ARCH'
distro='$DISTRO'
desc='$DESC'
pkgdesc='$DESC'
size='$SIZE'
url='$URL'
source=('')
dep=('')
EOF

	for i in ${deps[*]}; do
		echo depend="'$i'" >>$DESCME
	done
	return 0
}

sh_doinstallpkg() {
	(
		local packname="$1"
		local name_version_build
		local PRE_SH='info/pre.sh'
		local INSTALL_SH='info/.INSTALL'

		tar --dereference \
			--force-local \
			--use-compress-program=zstd \
			--extract \
			--preserve-permissions \
			--touch \
			--file "${packname}" -C "/tmp/" "./${DESCME}" "./${PRE_SH}" "./${INSTALL_SH}" >/dev/null 2>&-

		if [[ ! -e "/tmp/${DESCME}" ]]; then
			log_failure_msg2 "${red}ERROR! ${reset}I could not untar the file: ${orange}${packname}.desc${reset}"
			return 1
		fi
		source "/tmp/${DESCME}" || log_failure_msg2 "ERROR! could not load /tmp/${DESCME}. Archive not exist. ABORT!"

		if [[ -e "/tmp/${PRE_SH}" ]]; then
			log_msg "running pre.sh hook"
			bash "/tmp/${PRE_SH}"
		fi

		if [[ -e "/tmp/${INSTALL_SH}" ]]; then
			log_msg "running .INSTALL hook"
			bash "/tmp/${INSTALL_SH}"
		fi

		#name_version_build="${pkgname}-${version}-${build}"
		sh_splitpkg "$packname"
		name_version_build=${aPKGSPLIT[$PKG_BASE_VERSION]}
		tar --dereference \
			--force-local \
			--use-compress-program=zstd \
			--extract \
			--preserve-permissions \
			--touch \
			--file "${packname}" -C / | tee -a "$CACHEDIR_LIST/$name_version_build.list" || return 1

		sh_create_list "$1" || return 1
		sh_manage_scripts_and_archives "${packname}" || return 1
		sh_list_archives_directories "${name_version_build}"
	)
	fn_subshell_status
}

# -Sl
sh_initinstallpkg() {
	local param="$@"
	local pkg=
	local package
	local arr=
	local nfiles=

	if ! ((LALL)); then
		test $# -lt 1 && die "Missing value for the required argument '$param'. ${yellow}Try ${0##*/} -Sl <package>" 1
		_arg_unit="$2"
	fi

	shopt -s nullglob # enable suppress error message of a command
	if ((LALL)); then
		pkg="$pkg $(find "$PWD/" "$CACHEDIR_ARCHIVES/" -type f -iname "*.$PKG_EXT")"
	else
		for s in "${param[@]}"; do
			cfile=$(echo "$s" | sed 's/\// /g' | awk '{print $NF}')
			pkg="$pkg $(find "$PWD/" "$CACHEDIR_ARCHIVES/" -type f -iname "*.$PKG_EXT" | grep "$cfile")"
		done
	fi

	pkgCheckNumber=0
	LLIST=$true
	arr=("${pkg[*]}")
	nfiles=${#arr[*]}

	if ((nfiles)); then # pacote?
		for i in $pkg; do
			((LLIST)) && log_success_msg2 "${blue}FOUND local package ${orange}$i"
			((pkgCheckNumber++))
		done

		if ((pkgCheckNumber)); then
			if ! ((LAUTO)); then
				echo
				conf "$(DOT)continue installation?"
				LAUTO=$?
			fi
		fi

		if ((LAUTO)); then
			for package in $pkg; do
				log_wait_msg "Installing local package ${orange}$package"
				sh_installpkg "$package"
			done
		fi
	else
		msg "${orange}$param ${red}NOT FOUND ${reset}local package in ${orange}${CACHEDIR_ARCHIVES}${reset}"
		msg "${orange}$param ${red}NOT FOUND ${reset}local package in ${orange}${PWD} ${reset}"
		printf '%s\n' "${reset}Use: ${0##*/} -Sy to update with the repository${reset}"
	fi
	shopt -u nullglob # disable suppress error message of a command
}

sh_installpkg() {
	local cfileinstalled
	local fullname
	local package

	while [[ -n "$1" ]]; do
		fullname="$1"
		package="${fullname##*/}" ## tira o path
		sh_doinstallpkg "$fullname" || return $ERR_ERROR
		sh_splitpkg "$fullname" || return $ERR_ERROR
		cfileinstalled=${aPKGSPLIT[$PKG_BASE_VERSION]}
		cline=$(clinesplit)
		sed -i '/'"$cfileinstalled"'/d' "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" || return $ERR_ERROR
		echo "${cline}" >>"$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT"
		shift
	done
	return $ERR_OK
}

_GPG_SIGN() {
	local package=$1
	local sig='sig'

	#Pacote existe?
	if [[ ! -e "${package}.${PKG_EXT}" ]]; then
		printf '%s\n' "${red}[ERRO]${end} Unable to sign package. ${package}.${PKG_EXT}"
		printf '%s\n' "Reason: Package not found."
		printf '%s\n' "For security reasons, do not pass the package on to third parties."
		return 1
	fi

	[ "$REWRITE_SIGN" = "1" ] && rm -f "../$package.$PKG_EXT.$sig"
	[ "$REWRITE_SIGN" = "1" ] && rm -f "$package.$PKG_EXT.$sig"

	if which gpg >/dev/null 2>&-; then
		#Gerando Assinatura no pacote
		gpg --detach-sign --pinentry-mode loopback "${package}.${PKG_EXT}" >/dev/null 2>&- ||
			gpg --detach-sign "${package}.${PKG_EXT}" || return 1
		echo -e "${blue}[Create]${end} Your ${sig} on:   ../${package}.${PKG_EXT}.${sig}"
	fi
	return 0
}

fn_verify_on() {
	local package=$1
	local dir_info='info'
	local info_desc='desc'

	if [[ ! -d "$dir_info" ]]; then
		log_failure_msg2 "${red}[ERROR!]${end} ${pink}${dir_info}${end} directory\n"
		log_failure_msg2 "It's necessary your package have the DIRECTORY ${pink}info${end}."
		log_failure_msg2 "${pink}${dir_info}${end} its a directory store important archives."
		log_failure_msg2 "For more information use -h, --help."
		exit 77
	elif [[ ! -e "${dir_info}/${info_desc}" ]]; then
		log_failure_msg2 "${red}[ERROR!]${end} ${pink}${info_desc}${end} archive\n"
		log_failure_msg2 "It's necessary your package have the ARCHIVE ${pink}desc${end} inside of directory '${dir_info}'."
		log_failure_msg2 "${pink}${info_desc}${end} have informations of your package."
		log_failure_msg2 "For more information use -h, --help."
		exit 1
	else
		source "$dir_info/$info_desc"

		if [[ -z "$maintainer" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}maintainer${end} null"
			log_failure_msg2 "Enter the name of the package maintainer into variable maintainer."
			#exit 1
		elif [[ -z "$pkgname" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}pkgname${end} null"
			log_failure_msg2 "Enter the name of the package into variable pkgname."
			#exit 1
		elif [[ -z "$version" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}version${end} null"
			log_failure_msg2 "Enter a version of software into variable version."
			#exit 1
		elif [[ -z "$build" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}build${end} null"
			log_failure_msg2 "Enter the build number of package."
			#exit 1
		elif [[ -z "$desc" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}desc${end} null"
			log_failure_msg2 "Detail a small description into variable desc."
			#exit 1
		elif [[ -z "$url" ]]; then
			log_failure_msg2 "Check ${pink}${info_desc}${end}, VARIABLE ${blue}url${end} null"
			log_failure_msg2 "Enter a url of project/software into variable url."
			#exit 1
		fi
	fi

	for check_script in 'pre.sh' 'pos.sh' 'rm.sh'; do
		if [[ -e "${dir_info}/${check_script}" ]]; then
			if _GREP 'rm[[:space:]]+\-(rf|fr)' "${dir_info}/${check_script}" >/dev/null 2>&-; then
				log_failure_msg2 "${red}ERROR ${reset}${PWD}/${dir_info}/$check_script contain command rm -rf. ABORTED NOW."
				return 1
			fi
		fi
	done
	fn_subshell_status
}

fn_create_pkg() {
	local package=$1
	local ext_desc='desc'

	if tar --force-local --use-compress-program="zstd --ultra" --create --file ../"$package" .; then
		cp "$DESCME" ../"$package.$ext_desc" >/dev/null 2>&-
		pushd .. >/dev/null 2>&- || return 1
		if ((CREATE_SHA256)); then
			sha256sum "$package" >"$package".sha256
		fi
		if ((GPG_SIGN)); then
			_GPG_SIGN "$package" || return 1
			popd >/dev/null 2>&- || return 1
		else
			return 0
		fi
	fi
	evaluate_retval
}

fn_generatepkg() {
	local param="$@"

	if [[ ${#param} -eq 0 ]]; then # run standalone
		LAUTO=$true
		LLIST=$false
		pkg="${PWD##*/}.$PKG_EXT"
	else
		for s in "${param[@]}"; do
			pkg="$s"
			continue
		done
	fi

	((++ncount))
	((verbose >= 1)) && log_msg "$(fmt) Generating info for package $pkg"
	[[ ! -e "info/desc" ]] && LFORCE=$true

	if ((LAUTO)) || ((LFORCE)); then
		if [[ -z "$DESC_PACKNAME" ]]; then
			sh_splitpkg "$pkg"
			field_pkgname="${aPKGSPLIT[$PKG_BASE]}"
			field_pkgver="${aPKGSPLIT[$PKG_VERSION]}"
			field_version="${aPKGSPLIT[$PKG_VERSION]}"
			field_pkgrel="${aPKGSPLIT[$PKG_BUILD]}"
			field_build="${aPKGSPLIT[$PKG_BUILD]}"
		else
			field_pkgname="${DESC_PACKNAME}"
			field_pkgver="${DESC_VERSION}"
			field_version="${DESC_VERSION}"
			field_pkgrel="${DESC_BUILD}"
			field_build="${DESC_BUILD}"
		fi
		[[ -z "$field_build" ]] && field_build="$DESC_BUILD"
		[[ -z "$DESC" ]] && DESC="$field_pkgname-$field_version"

		fn_generate_desc "$field_pkgname" "$field_version" "$field_build" "${field_pkgver::-2}" "$field_pkgrel" || return $ERR_ERROR
	fi
	return $ERR_OK
}

fn_createpkg() {
	local param="$@"
	local s
	local pkg=()

	for s in "${param[@]}"; do pkg="$s"; done
	[[ -z "$pkg" ]] && pkg=$(echo "$PWD" | sed 's/\// /g' | awk '{print $NF}')
	((verbose >= 1)) && log_msg "$(fmt) Building package $pkg"

	pkg="$pkg.$PKG_EXT"
	fn_generatepkg "$pkg"
	fn_name_format_pkg "$pkg" || exit 1
	fn_verify_on "$pkg" || exit 1
	fn_create_pkg "$pkg" || exit 1
	((++ncount))
	((verbose >= 1)) && log_msg "$(fmt) Generating package ${yellow}$pkg"
}

# -Sa
fn_alienpkg_main() {
	fn_alienpkg_initvars "$*"
	fn_alienpkg_exec "$*"
}

fn_alienpkg_initvars() {
	BUILDDIR="${PKGCORE:=${CACHEDIR}/archives}"
	[[ -n "${BUILDDIR}" ]] || BUILDDIR="${CACHEDIR}/archives" >/dev/null 2>&-
	[[ -d "${BUILDDIR}" ]] || mkdir -p "${BUILDDIR}" >/dev/null 2>&-
}

fn_alienpkg_exec() {
	local param="$@"
	local pkg
	local package
	local LFORCELOCAL
	local string
	local ntotalpkg=0
	local ntotalfindpkgs=0
	local ncount=0
	local arraypkg
	local npackagesprocessed=0
	local firstletter
	local FilteredPackage
	local destpkgGIT
	local destpkgCORE
	export deps

	if [[ -z "$param" ]]; then
		LALL=$true
	else
		LALL=$false
		for s in "${param[@]}"; do string+="$s"; done
	fi

	if ((LALL)); then
		if ! ((LTIME)); then
			mapfile -t pkg < <(find "$ALIEN_CACHE_DIR/" -regextype posix-egrep -regex "$RE_ALIEN" -type f)
		else
			mapfile -t pkg < <(find "$ALIEN_CACHE_DIR/" -regextype posix-egrep -regex "$RE_ALIEN" -type f -mtime "$mtime")
		fi
	else
		for str in $string; do
			if ! ((LTIME)); then
				pkg+=($(find $ALIEN_CACHE_DIR/ -iname "*$str*" -regextype posix-egrep -regex "$RE_ALIEN" -type f))
			else
				pkg+=($(find $ALIEN_CACHE_DIR/ -iname "*$str*" -regextype posix-egrep -regex "$RE_ALIEN" -type f -mtime "$mtime"))
			fi
		done
	fi

	#	arraypkg=("$pkg")
	#	ntotalpkg=${#arraypkg[*]}
	ntotalpkg=${#pkg[*]}
	ntotalfindpkgs=$ntotalpkg
	LFORCELOCAL=$LFORCE

	if ((ntotalpkg)); then # package found?
		#		for package in $pkg
		for package in ${pkg[*]}; do
			ncount=0
			pkgtar=${package##*/}          #remove diretorio deixando somente nome do pacote
			pkgtar=${pkgtar%%.pkg.tar.zst} #remove .tar.zst ext
			pkgtar=${pkgtar%%.pkg.tar.xz}  #remove .tar.xz ext
			! ((CHILI_OS)) && pkgtar=${pkgtar%%-any}
			! ((CHILI_OS)) && pkgtar=${pkgtar%%-x86_64}
			cPacoteSemExt=${pkgtar%%.*}       # https://elmord.org/blog/?entry=20121227-manipulando-strings-bash
			cPacoteSemExt=${cPacoteSemExt%-*} # https://elmord.org/blog/?entry=20121227-manipulando-strings-bash

			if ! ((LFORCELOCAL)); then
				firstletter=${pkgtar::1}
				FilteredPackage=$pkgtar.$PKG_EXT
				destpkgGIT="${GITDIR}/packages/${firstletter}/${FilteredPackage}"
				destpkgCORE="${GITDIR}/packages/core/${FilteredPackage}"

				if [[ -e "$destpkgGIT" || -e "$destpkgCORE" ]]; then
					((verbose >= 2)) && log_failure_msg2 "$(fmt) ${orange}$FilteredPackage ${reset}Package already exist in ${green}$GITDIR/packages/$firstletter/${reset} Use the -f option to force rebuild."
					((--ntotalpkg))
					continue
				fi
			fi

			destdir="$BUILDDIR/$pkgtar"
			((++ncount))
			((verbose >= 1)) && log_msg "$(fmt) Creating directory $destdir"
			mkdir -p "$destdir" >/dev/null 2>&-

			((++ncount))
			((verbose >= 1)) && log_msg "$(fmt) Unpacking package $package at $destdir"
			tar --use-compress-program=zstd --force-local --extract --file "$package" -C "$destdir" >/dev/null 2>&-

			case $package in
			luit-[0-9]*) sed -i -e "/D_XOPEN/s/5/6/" configure ;;
			esac

			sed -i 's/ = /="/g' "$destdir/.PKGINFO" >/dev/null 2>&-
			sed -i 's/$/"/g' "$destdir/.PKGINFO" >/dev/null 2>&-
			source "$destdir/.PKGINFO"

			export DESC_BUILD="${pkgtar: -1}"
			export URL="$url"
			export LICENSE="$license"
			export ARCH="$arch"
			export SIZE="$size"
			export DESC="$pkgdesc"
			export DEP="$depend"
			export DESC_PACKNAME="$pkgname"
			export DESC_VERSION="$pkgver"
			export DESC_BUILD="${pkgver: -1}"

			deps=$(grep ^depend "$destdir"/.PKGINFO | awk -F'"' '{print $2}')
			pushd "$destdir" >/dev/null 2>&- || return 1
			rm -f "$destdir"/.BUILDINFO "$destdir"/.MTREE "$destdir"/.PKGINFO >/dev/null 2>&-

			((++ncount))
			fn_createpkg "$pkgtar"
			((verbose >= 1)) && echo
			((--ntotalpkg))
			((++npackagesprocessed))
		done

		((verbose >= 1)) && log_msg "Total alien packages found     : $ntotalfindpkgs"
		((verbose >= 1)) && log_msg "Total alien packages processed : $npackagesprocessed  ${green}Use the --force option to force rebuild."

		if ! ((LKEEP)); then
			((++ncount))
			((verbose >= 1)) && log_msg "Verifying candidate packages files for pruning"
			#removeoldpkgchili $cPacoteSemExt
			#			fetchpack -q -c "$GITDIR/packages/" -m /tmp/ "$cPacoteSemExt"
		fi
	else
		log_failure_msg "${red}error: ${orange}$x ${reset}package target ${yellow}${param} ${reset}was ${red}NOT ${reset}found in ${yellow}${ALIEN_CACHE_DIR} ${reset}for import"
	fi
	unset size ncount ntotalpkg
	popd >/dev/null 2>&- || return 1
}

fn_alienpkg_pkgsize() {
	size="$(du -sk --apparent-size)"
	size="$((${size%%[^0-9]*} * 1024))"
}

fn_alienpkg_logo() {
	cat <<'EOF'
       _ _                  _
  __ _| (_) ___ _ __  _ __ | | ____ _
 / _` | | |/ _ \ '_ \| '_ \| |/ / _` |
| (_| | | |  __/ | | | |_) |   < (_| |
 \__,_|_|_|\___|_| |_| .__/|_|\_\__, |
                     |_|        |___/
EOF
	sh_version
}

sh_upgrade() {
	local param="$@"
	local LLIST=$false
	local count=0
	local s
	local item
	local cBaseInstalled cBaseVersionInstalled cVersionInstalled
	local cBase cBaseVersion cVersion
	local ntotalconfered
	local pkgrepo
	local ntotal_pkg_listed

	((verbose > 1)) || verbose=0
	LDEPS=$false
	LEXACT=$true
	LLIST=$false
	fn_listpkgdisp "$CACHEDIR_SEARCH/$PACKAGES_INSTALLED_SPLIT" "$param"

	local ntotal_pkg_listed=${public_ntotal_pkg_listed}

	for i in $public_pkg; do
		sh_splitpkg "$i"
		cBaseInstalled="${aPKGSPLIT[PKG_BASE]}"
		cBaseVersionInstalled="${aPKGSPLIT[PKG_BASE_VERSION]}"
		cVersionInstalled="${aPKGSPLIT[PKG_VERSION]}"
		pkgrepo=$(grep ^"$cBaseInstalled$SEP" "$CACHEDIR_SEARCH/$PACKAGES_SPLIT" | cut -d$SEP -f4)
		count=0
		((ntotalconfered++))

		if [[ "${#pkgrepo}" -gt 0 ]]; then # pacote?
			for cPkg in ${pkgrepo}; do
				sh_splitpkg "$cPkg"
				cBase="${aPKGSPLIT[PKG_BASE]}"
				cBaseVersion="${aPKGSPLIT[PKG_BASE_VERSION]}"
				cVersion="${aPKGSPLIT[PKG_VERSION]}"

				case "$cBase" in
				Python) continue ;;
				gtk+) continue ;;
				esac

				if [[ "$cBaseInstalled" == "$cBase" ]]; then
					((count++))
					if [[ "$(vercmp "$cBaseVersionInstalled" "$cBaseVersion")" -lt 0 ]]; then
						log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is being updated to newest version ($cVersion)."
						sh_doremove "$cBaseVersionInstalled" "OFF"
						LAUTO=$true
						LFORCE=$true
						LDEPS=$false
						sh_install "$cBase"
					elif [[ "$cBaseVersionInstalled" = "$cBaseVersion" ]]; then
						if ((LFORCE)); then
							LAUTO=$true
							LFORCE=$true
							LDEPS=$false
							sh_install "$cBase"
							continue
						else
							log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is already the newest version ${green}($cVersionInstalled)${reset}. Use the -f option to force reinstallation."
							continue
						fi
					else
						if ((LFORCE)); then
							LAUTO=$true
							LFORCE=$true
							LDEPS=$false
							sh_install "$cBase"
						else
							log_success_msg2 "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}is already the newest version ($cVersionInstalled)."
						fi
						if ((count > 1)); then
							log_warning_msg "${orange}${cBaseInstalled} ${red}WARNING!! there is more than one release of the package in the repo!"
						fi
					fi
				else
					log_warning_msg "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBase} ${reset}not installed."
				fi
			done
		else
			log_warning_msg "[$ntotalconfered/$ntotal_pkg_listed]${orange}${cBaseInstalled} ${red}WARNING!! package not in repo! Use 'fetch update' to update the database"
		fi
	done

	if [[ "${#public_pkg}" -le 1 ]]; then # nenhum pacote?
		log_warning_msg "$orange$param$cyan package not installed"
		echo
		if conf "${blue}:: ${reset}Install Pakages(s)?"; then
			LAUTO=$true
			LFORCE=$true
			LDEPS=$false
			sh_install "$param"
		fi
	fi
	sh_cdroot
}

checkDependencies() {
	local errorFound=0
	declare -a missing

	for d in "${DEPENDENCIES[@]}"; do
		[[ -z $(command -v "$d") ]] && missing+=("$d") && errorFound=1 && printf '%s\n' "ERRO: não encontrei o comando '$d'"
	done
	#[[ ${#missing[@]} -ne 0 ]]
	if ((errorFound)); then
		echo "---IMPOSSÍVEL CONTINUAR---"
		echo "Esse script precisa dos comandos listados acima" >&2
		echo "Instale-os e/ou verifique se estão no seu \$PATH" >&2
		exit 1
	fi
}

sh_cleaning() {
	log_msg "${pink}Cleaning temporary files${reset}"
	rm -rf "${TMP_DIR_ROOT:?}"/ >/dev/null 2>&-
}

sh_backup() {
	if ((verbose >= 2)); then
		log_msg "${pink}Making backup: $CACHEDIR_SEARCH/${reset}"
	fi
	mkdir -p "$TMP_DIR_BACKUP"/ >/dev/null 2>&-
	mkdir -p "$TMP_DIR_FOLDERS"/ >/dev/null 2>&-
	cp -f "$CACHEDIR_SEARCH"/* "$TMP_DIR_BACKUP"/ >/dev/null 2>&-
}

sh_version() {
	orange=$(tput setaf 166)
	printf "%s\n" "${orange}${0##*/} v${_VERSION_}"
}

#figlet
logo() {
	cat <<'EOF'
  __      _       _
 / _| ___| |_ ___| |__     Copyright (c) 2019-2022 Vilmar Catafesta <vcatafesta@gmail.com>
| |_ / _ \ __/ __| '_ \    Copyright (c) 2019-2022 Chili GNU/Linux Development Team <root@chililinux.com>
|  _|  __/ || (__| | | |
|_|  \___|\__\___|_| |_|   Este programa pode ser redistribuído livremente
                           sob os termos da Licença Pública Geral GNU.
EOF
	sh_version
}

fetchpack_configure() {
	#  fetchpack - A flexible cache cleaning utility in ChiliOS
	#########################################################################
	declare -a cachedirs=() candidates=() cmdopts=() candesc=()
	declare -i delete=0 dryrun=0 move=0 totalsaved=0 pkgcount=0
	declare -i verbose=0 ctime=0 QUIET=0
	declare delim=$'\n'
	declare keep=1
	declare movedir=
	declare USE_COLOR='y'
	# Expand to nothing if there are no matches
	shopt -s nullglob
	shopt -s extglob

	# flag's para split package
	: "${aPKGSPLIT=()}"
	: "${aPKGLIST=}"
	: "${PKG_FOLDER_DIR=0}"
	: "${PKG_FULLNAME=1}"
	: "${PKG_ARCH=2}"
	: "${PKG_BASE=3}"
	: "${PKG_BASE_VERSION=4}"
	: "${PKG_VERSION=5}"
	: "${PKG_BUILD=6}"
}

fetchpack_main() {
	local nfiles=0
	local pkg=
	local pkgInAll=
	local pkg_base=
	local candidates=()
	local cachedir
	local re="$FETCH_RE"

	if ((QUIET)); then
		verbose=0
	else
		if ((verbose)); then
			if ((dryrun)); then
				log_msg "${white}running mode => ${green}DRY-RUN"
			elif ((delete)); then
				log_msg "${white}running mode => ${red}DELETE"
			elif ((move)); then
				log_msg "${white}running mode => ${yellow}MOVE"
			fi
		fi
	fi

	for cachedir in "${cachedirs[@]}"; do
		[[ -d $cachedir ]] || {
			log_failure_msg2 "${red}Error: cachedir '$cachedir' does not exist or is not a directory -- skipping"
			continue
		}
		pushd "$cachedir" &>/dev/null || die "Error: failed to chdir to $cachedir"

		if [ $# -lt 1 ]; then
			AllOldPackages=$(find "$PWD" -type f -iname "*.$PKG_EXT" | sort -Vr | awk -F "$re" 'lista[$1]++')
		else
			AllOldPackages=$(find "$PWD" -type f -iname "*.$PKG_EXT" | grep "$1" | sort -Vr | awk -F "$re" 'lista[$1]++')
		fi

		while read -r pkgInAll; do
			pkg_base="$pkgInAll"
			[[ -z "$pkg_base" ]] && continue
			((++pkgNumber))

			if ((verbose >= 3)); then
				printf "  $(DOT)${white}candidate package ${purple}(%04d) ${green}%s\n" "$pkgNumber" "$pkg_base"
			fi
			[[ -e "$pkgInAll" ]] && candidates+=("$pkgInAll")
			[[ -e "$pkgInAll.desc" ]] && candesc+=("$pkgInAll.desc")
		done <<<"$AllOldPackages" #done < <(printf '%s\n' "$AllOldPackages") #done <<< $(printf '%s\n' "$AllOldPackages")
		popd >/dev/null 2>&1
	done

	if ((!${#candidates[*]})); then
		log_msg "${green}NO candidates packages found for pruning"
		return 1
	fi

	if ((verbose >= 2)); then
		pkgNumber=0
		while read -r pkg; do
			((++pkgNumber))
			printf "  $(DOT)${white}found package ${purple}(%04d) ${green}%42s\n" "$pkgNumber" "$pkg"
		done <<<"$(printf '%s\n' "${candidates[@]}")"
		#done < <(printf '%s\n' "${candidates[@]}") #done <<< "${candidates[@]}"
	fi

	ncandidates=${#candidates[*]}
	ncandesc=${#candesc[*]}
	pkgcount=$((ncandidates + ncandesc))

	((ncandidates)) && totalsaved=$(printf '%s\0' "${candidates[@]}" | xargs -0 stat -c %s | awk '{ sum += $1 } END { print sum }')
	((ncandesc)) && totalsaved+=$(printf '%s\0' "${candesc[@]}" | xargs -0 stat -c %s | awk '{ sum += $1 } END { print sum }')
	set -o errexit # Exit immediately if a pipeline returns non-zero.

	if ((delete)); then
		((verbose)) && cmdopts+=(-v)
		cmdopts+=(-f)
		((ncandidates)) && printf '%s\0' "${candidates[@]}" | runcmd xargs -0 rm "${cmdopts[@]}"
		((ncandesc)) && printf '%s\0' "${candesc[@]}" | runcmd xargs -0 rm "${cmdopts[@]}"
	elif ((move)); then
		((verbose)) && cmdopts+=(-v)
		cmdopts+=(-f)
		((ncandidates)) && printf '%s\0' "${candidates[@]}" | runcmd xargs -0 mv "${cmdopts[@]}" -t "$movedir"
		((ncandesc)) && printf '%s\0' "${candesc[@]}" | runcmd xargs -0 mv "${cmdopts[@]}" -t "$movedir"
	elif ((verbose)); then
		((ncandidates)) && printf '%s\0' "${candidates[@]}" | xargs -0 printf "  $(DOT)%s\n" "${cmdopts[@]}"
		((ncandesc)) && printf '%s\0' "${candesc[@]}" | xargs -0 printf "  $(DOT)%s\n" "${cmdopts[@]}"
	fi

	if ((!QUIET)); then
		if ((dryrun)); then
			msg "${yellow}$output finish dry-run (packages found: $ncandidates with .desc) (disk space saved: %s)" "$(size_to_human "$totalsaved")"
		else
			msg "$output (packages found: $ncandidates with .desc) (disk space saved: %s)" "$(size_to_human "$totalsaved")"
		fi
	fi
	return 0
}

fetchpack_usage() {
	cat <<EOF
${cyan}Usage: ${yellow}fetch -Sc <operation> [options] [targets...]${reset}

  Operations:
${red}     -d, --dryrun          ${reset}perform a dry run, only finding candidate packages.
${red}     -m, --move <dir>      ${reset}move candidate packages to "dir".
${red}     -r, --remove          ${reset}remove candidate packages.

  Options:
${red}     -c, --cachedir <dir>  ${reset}scan "dir" for packages. can be used more than once.
                           (default: read from /etc/fetch/fetch.conf).
${red}     -k, --keep <num>      ${reset}keep "num" of each package in the cache (default: 1).
${red}     -f, --force           ${reset}apply force to mv(1) and rm(1) operations.
${red}     -h, --help            ${reset}display this help message and exit.
${red}         --nocolor         ${reset}remove color from output.
${red}     -q, --quiet           ${reset}quiet output.
${red}     -v, --verbose         ${reset}increase verbosity. specify up to 3 times ([-v][-vv][-vvv]).

${cyan}most common use: ${yellow}fetch -Sc -k1 -r -v${reset}
EOF
}

fetchpack_init() {
	#	sh_checkroot
	#	checkDependencies
	fetchpack_configure

	OPT_SHORT=':a:c:dfhi:k:m:qrsuVvzt:'
	OPT_LONG=('arch:' 'cachedir:' 'dryrun' 'force' 'help' 'ignore:' 'keep:' 'move:' 'nocolor' 'quiet' 'remove' 'uninstalled' 'version' 'verbose' 'null' 'ctime:')

	if ! parseopts "$OPT_SHORT" "${OPT_LONG[@]}" -- "$@"; then
		return 1
	fi
	set -- "${OPTRET[@]}"
	unset OPT_SHORT OPT_LONG OPTRET

	while :; do
		case $1 in
		-t | --ctime)
			ctime="$2"
			shift
			;;
		-c | --cachedir)
			cachedirs+=("$2")
			shift
			;;
		-d | --dryrun)
			dryrun=1
			;;
		-f | --force)
			cmdopts=(-f)
			;;
		-h | --help)
			fetchpack_usage
			return
			;;
		-m | --move)
			move=1 movedir=$2
			shift
			;;
		--nocolor)
			unsetvarcolors
			USE_COLOR='n'
			;;
		-q | --quiet)
			unsetvarcolors
			QUIET=1
			;;
		-r | --remove)
			delete=1
			;;
		-V | --version)
			logo
			return
			;;
		-v | --verbose)
			((++verbose))
			;;
		-z | --null)
			delim='\0'
			;;
		--)
			shift
			break 2
			;;
		esac
		shift
	done

	# check if messages are to be printed using color
	if [[ -t 2 && $USE_COLOR != "n" ]]; then
		setvarcolors
	fi

	# setting default cachedirs
	if [[ -z "${cachedirs[*]}" ]]; then
		[[ -n "$GITDIR" ]] && cachedirs=("$GITDIR")
		cachedirs+=("/var/cache/fetch/archives")
	fi

	# sanity checks
	case $((dryrun + delete + move)) in
	0) die "no operation specified (use -Sc -h for help)" ;;
	[^1]) die "only one operation may be used at a time" ;;
	esac

	[[ $movedir && ! -d $movedir ]] && die "destination directory '$movedir' does not exist or is not a directory!"

	if ((move || delete)); then
		# make it an absolute path since we're about to chdir
		[[ $movedir && ${movedir:0:1} != '/' ]] && movedir=$PWD/$movedir
		[[ $movedir && ! -w $movedir ]] && needsroot=1
	fi

	fetchpack_main "$@"
}

usage() {
	tput sgr0 # reset colors
	bold=$(tput bold)
	reset=$(tput sgr0)
	red=$(tput setaf 124)
	yellow=$(tput setaf 136)
	pink=$(tput setaf 129)

	cat <<EOF
${cyan}Most used commands:
${red}  -h,  help           ${reset}- display this help and exit
${red}  -Sy, update         ${reset}- update list packages in the repository online. Need Internet
${red}  -S,  install        ${reset}- install packages
${red}  -Ss, search         ${reset}- search for packages
${red}  -Su, upgrade        ${reset}- upgrade packages
${red}  -Sw, download       ${reset}- only download the binary package into cache directory
${red}  -Sr, recreate       ${reset}- recreate database installed packages
${red}  -Sa, alienpkg       ${reset}- import package from ArchLinux
${red}  -Sg, generate       ${reset}- generate info package from source
${red}  -C,  create         ${reset}- build package
${red}  -Sl, local          ${reset}- install local package
${red}  -Sc, clean          ${reset}- erase downloaded packages files
${red}  -Sm, meta           ${reset}- install meta packages
${red}  -R,  remove         ${reset}- remove packages
${red}  -La, list-avaiable  ${reset}- list avaiable packages based on package names
${red}  -Lc, list-cache     ${reset}- list downloaded packages in cache
${red}  -Li, list-installed ${reset}- list installed packages
${red}  -Po, out-cache      ${reset}- list packages out-cache
${red}  -Pi, in-cache       ${reset}- list downloaded packages in cache
${red}  -Qi, show           ${reset}- show package details
${red}  -Qq, total          ${reset}- total packages installed
${red}  -V,  version        ${reset}- output version information and exit
${red}  --nocolor           ${reset}- remove color from output
${red}  --table             ${reset}- output in columns
${red}  --verbose           ${reset}- verbose output
${cyan}ex:
  ${reset}fetch ${pink}-Sy ${reset} self ${yellow}=> Update self fetch via internet
  ${reset}fetch ${pink}-Sy ${reset}      ${yellow}=> Update database
  ${reset}fetch ${pink}-Syy${reset}      ${yellow}=> Force update database
  ${reset}fetch ${pink}-S  ${reset}<package> [<...>] [--all] [--noconfirm] [--force] [--nodeps]
  ${reset}fetch ${pink}-R  ${reset}<package> [<...>] [--all] [--noconfirm] [--force]
  ${reset}fetch ${pink}-Su ${reset}[<package>] [<...>] [--all] [--nonconfirm] [--force]
  ${reset}fetch ${pink}-Ss ${reset}<package> [<...>] [--noconfirm] [--force] [--exact] [--nodeps]
  ${reset}fetch ${pink}-Li ${reset}[<package>] [<...>] [--all] [--exact]
  ${reset}fetch ${pink}-Sw ${reset}[<package>] [<...>] [--all] [--noconfirm] [--force]
  ${reset}fetch ${pink}-Qi ${reset}[<package> [<...>]]
  ${reset}fetch ${pink}-C  ${reset}[<packname-version-build>]
  ${reset}fetch ${pink}-Sm ${reset}<xorg> [--noconfirm] [--force]
  ${reset}fetch ${pink}-Sa ${reset}<package> [<...>] [--all] [--noconfirm] [--force] [--mtime=<n>] [--keep] [--default]
EOF
}

sh_parseparam() {
	local param="$*"
	local s
	local newparam

	LDEPS=$true
	LAUTO=$false
	LFORCE=$false
	verbose=1
	mtime=0
	SPLITPOS='4'
	LLIST=$false
	LEXACT=$false
	LALL=$false
	LSELF=$false
	LKEEP=$false
	LTIME=$false
	LSEARCHONLY=$true
	LSKIPERROR=$false
	LTABLE=$false

	for s in $param; do
		[[ $(tolower "${s:0:8}") = "--mtime=" ]] && {
			LTIME=$true
			mtime="${s:8}"
			continue
		}
		[[ $(tolower "${s}") = "--default" ]] && {
			LTIME=$true
			LKEEP=$true
			LALL=$true
			continue
		}
		[[ $(tolower "${s}") = "--keep" ]] && {
			LKEEP=$true
			continue
		}
		[[ $(tolower "${s}") = "self" ]] && {
			LSELF=$true
			continue
		}
		[[ $(tolower "${s}") = "--self" ]] && {
			LSELF=$true
			continue
		}
		[[ $(tolower "${s}") = "--nodeps" ]] && {
			LDEPS=$false
			continue
		}
		[[ $(tolower "${s}") = "-y" ]] && {
			LAUTO=$true
			continue
		}
		[[ $(tolower "${s}") = "--auto" ]] && {
			LAUTO=$true
			continue
		}
		[[ $(tolower "${s}") = "--noconfirm" ]] && {
			LAUTO=$true
			continue
		}
		[[ $(tolower "${s}") = "-f" ]] && {
			LFORCE=$true
			continue
		}
		[[ $(tolower "${s}") = "--force" ]] && {
			LFORCE=$true
			continue
		}
		[[ $(tolower "${s}") = "--noverbose" ]] && {
			verbose=0
			continue
		}
		[[ $(tolower "${s}") = "--verbose" ]] && {
			verbose=2
			continue
		}
		[[ $(tolower "${s}") = "--v" ]] && {
			verbose=1
			continue
		}
		[[ $(tolower "${s}") = "--vv" ]] && {
			verbose=2
			continue
		}
		[[ $(tolower "${s}") = "--vvv" ]] && {
			verbose=3
			continue
		}
		[[ $(tolower "${s}") = "-v" ]] && {
			verbose=1
			continue
		}
		[[ $(tolower "${s}") = "-vv" ]] && {
			verbose=2
			continue
		}
		[[ $(tolower "${s}") = "-vvv" ]] && {
			verbose=3
			continue
		}
		[[ $(tolower "${s}") = "-q" ]] && {
			verbose=0
			continue
		}
		[[ $(tolower "${s}") = "--quiet" ]] && {
			verbose=0
			continue
		}
		[[ $(tolower "${s}") = "off" ]] && {
			LLIST=$false
			continue
		}
		[[ $(tolower "${s}") = "on" ]] && {
			LLIST=$true
			continue
		}
		[[ $(tolower "${s}") = "--exact" ]] && {
			LEXACT=$true
			continue
		}
		[[ $(tolower "${s}") = "all" ]] && {
			LALL=$true
			continue
		}
		[[ $(tolower "${s}") = "--all" ]] && {
			LALL=$true
			continue
		}
		[[ $(tolower "${s}") = "--skiperror" ]] && {
			LSKIPERROR=$true
			continue
		}
		[[ $(tolower "${s}") = "--nocolor" ]] && {
			unsetvarcolors
			continue
		}
		[[ $(tolower "${s}") = "--table" ]] && {
			LTABLE=$true
			continue
		}
		#		newparam="$newparam $(echo ${s})"
		newparam+="$s "
	done
	log_prefix
	init $newparam
}

init() {
	while test $# -gt 0; do
		case "${1}" in
		-Si | -S | install)
			shift
			LSEARCHONLY=$false
			LLIST=$true
			sh_install "$@"
			return
			;;
		-Sl | local)
			shift
			sh_initinstallpkg "$@"
			exit
			;;
		-Sa | alienpkg)
			shift
			fn_alienpkg_main "$@"
			return
			;;
			#			-Sc|clean)  									shift;sh_clean "$@";exit;;
		-Sc | clean)
			shift
			fetchpack_init "$@"
			exit
			;;
		-c | -C | create)
			shift
			fn_createpkg "$@"
			exit
			;;
		-Sg | -g | generate)
			shift
			fn_generatepkg "$@"
			exit
			;;
		-Ss | search)
			shift
			sh_search "$@"
			exit
			;;
		-Sy | update)
			shift
			fn_updaterepo "$@"
			exit
			;;
		-Syy | refresh)
			shift
			fn_update "$@"
			exit
			;;
		-Sm | --meta | meta)
			shift
			sh_installmeta "$@"
			exit
			;;
		-R | remove)
			shift
			sh_remove "$@"
			exit
			;;
		-Sw | download)
			shift
			sh_download "$@"
			exit
			;;
		-Sr | recreate)
			shift
			LLIST=$true
			sh_recreatefilepackagesinstalled
			exit
			;;
		-Qq | total)
			shift
			sh_totalpackagesinstalled
			exit
			;;
		-L | list)
			shift
			LLIST=$true
			sh_list "$@"
			exit
			;;
		-La | avaiable)
			shift
			LLIST=$true
			sh_list "$@"
			exit
			;;
		-Lc | list-cache)
			shift
			LLIST=$true
			fn_pkgincache "$@"
			exit
			;;
		-Pi | in-cache)
			shift
			LLIST=$true
			fn_pkgincache "$@"
			exit
			;;
		-Li | list-installed)
			shift
			LLIST=$true
			sh_listinstalled "$@"
			exit
			;;
		-Po | out-cache)
			shift
			LLIST=$true
			sh_pkgoutcache "$@"
			exit
			;;
		-Qi | show)
			shift
			sh_show "$@"
			exit
			;;
		-Su | upgrade)
			shift
			sh_upgrade "$@"
			exit
			;;
		-V* | --version | version)
			logo
			exit 0
			;;
		-f* | --force) LFORCE=1 ;;
		-y* | --auto) LAUTO=1 ;;
		-exact | --exact) LEXACT=1 ;;
		-q | --quiet) verbose=0 ;;
		--nocolor) unsetvarcolors ;;
		--table) LTABLE=1 ;;
		-v* | --no-verbose | --verbose)
			((++verbose))
			test "${1:0:5}" = "--no-" && verbose=0
			;;
		-h | --help)
			usage
			exit $(($# ? 0 : 1))
			;;
			#      	*)													usage;exit 0;_last_positional="$1";_positionals+=("$_last_positional");_positionals_count=$((_positionals_count + 1));;
		*) die "operation not supported: $1 (use -h for help)" ;;
		esac
		shift
	done
}

parsestdin() {
	file=${1--} # POSIX-compliant; ${1:--} can be used either.
	IFS=$'\n'
	while read -r line; do
		echo "$line"
		init -a "$line"
	done </dev/stdin
	#done < <(cat -- "$file")
	#done < <(cat /dev/stdin)
	#done < /dev/stdin
	#done < <(cat "$@")
}

[[ -z "${1-}" ]] && die "no operation specified (use -h for help)"
[[ "$1" = @(-H|-h|help|-help|--help) ]] && {
	usage
	exit $(($# ? 0 : 1))
}
[[ "$1" = @(-V|-v|version|-version|--version) ]] && {
	logo
	exit $(($# ? 0 : 1))
}

cleanup() {
	echo
	echo "Interrupt signal received"
	log_msg "${pink}Cleaning...${reset}"
	cp -f "$TMP_DIR_BACKUP"/* "$CACHEDIR_SEARCH"/ >/dev/null 2>&-
	rm -rf "${TMP_ROOT_BACKUP}"/ >/dev/null 2>&-
	rm -f "/tmp/ARRAYPKGFULL"
	kill -TERM -$$
	exit
}
#trap "" 2 				# disable Ctlr+C
#trap    2  	 		# enable Ctlr+C
set -m
trap - INT
trap 'cleanup' 2 # SIGINT SIGTERM SIGTSTP

configure
checkDependencies
sh_checkroot "$@"
sh_checkdir
sh_arraypkgfull
sh_parseparam "$@"

: <<'comment'
if [ -p /dev/stdin ]; then
	#for FILE in "$@" /dev/stdin
	for FILE in /dev/stdin
	do
		while IFS= read -r LINE
		do
			#echo "$LINE"
			init "$@" "$LINE"
		done < "$FILE"
	done
else
	# init "$@"
	sh_parseparam "$@"
fi
comment

# vim:set ts=3 sw=3 et:

# CodeBlock?
# Ponteiro=Var ; Var='Valor apontado'
# echo ${!Ponteiro}
