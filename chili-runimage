#!/usr/bin/env bash
#shellcheck disable=SC2034,SC2155,SC2154,SC2181

#  chili-runimage
#  Created: 2023/04/25
#  Altered: 2023/08/31
#
#  Copyright (c) 2023-2023, Vilmar Catafesta <vcatafesta@gmail.com>
#  All rights reserved.
#
#  Redistribution and use in source and binary forms, with or without
#  modification, are permitted provided that the following conditions
#  are met:
#  1. Redistributions of source code must retain the above copyright
#     notice, this list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright
#     notice, this list of conditions and the following disclaimer in the
#     documentation and/or other materials provided with the distribution.
#
#  THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
#  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
#  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
#  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
#  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
#  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
#  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
#  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
#  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
#  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

#debug
export PS4='${red}${0##*/}${green}[$FUNCNAME]${pink}[$LINENO]${reset} '
#set -x
#set -e

#system
readonly APP="${0##*/}"
readonly _VERSION_='1.1.16-20230831'
readonly DEPENDENCIES=('tput' 'printf' 'qemu-system-x86_64')
readonly PACKAGEDEP=([tput]='ncurses' [printf]='coreutils' [qemu-system-x86_64X]='qemu')
readonly xmem='8G'
readonly iface_bridge='br0'
declare -i uefi=0
declare -i bridge=0
declare -a qemu_options=()
trap cleanup_working_dir EXIT

function cleanup_working_dir {
	if [[ -d "${working_dir}" ]]; then
		rm -rf -- "${working_dir}"
	fi
}

function die {
	local msg=$1; shift
	printf "  %b %s\\n" "${CROSS}" "${bold}${red}${msg}"
	exit 1
}

function log_msg() {
	local retval="${PIPESTATUS[0]}"

	if [[ $retval -eq 0 ]]; then
		printf "  %b %s\\n" "${TICK}" "${*}"
	else
		printf "  %b %s\\n" "${CROSS}" "${*}"
	fi
}

function sh_checkRoot {
	local str="Root user check"
	if [[ "$(id -u)" != "0" ]]; then
		die "${red} error: you cannot perform this operation unless you are root."
	fi
	printf "  %b %s\\n" "${TICK}" "${str}"
	return 0
}

function sh_version {
	printf "${orange}${0##*/} v${_VERSION_}${reset}\n"\
"   ${bold}Copyright (C) 2023 vcatafesta@gmail.com\n"\
"   GPLv3+ License: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>\n"\
"   This is free software: you are free to change and redistribute it.\n"\
"   THERE IS NO WARRANTY, to the fullest extent permitted by law.${reset}\n"
	exit 0
}

function sh_usage {
cat <<EOF
Usage:
	${orange}$APP ${reset} [Options]

Options:
	-h|--help              print this help
	-u|--uefi              set boot type to 'UEFI'
	-b|--bridge            configure net as bridge
	-n|--nocolor           remove colors from output
	-V|--version           print version

Example:
	Run an image/disk using UEFI:
	$ ${orange}$APP${reset} -u file.iso
	$ ${orange}$APP${reset} -u file.img
	$ ${orange}$APP${reset} -u /dev/sdX

	Run an image/disk using BIOS:
	$ ${orange}$APP${reset} file.iso
	$ ${orange}$APP${reset} file.img
	$ ${orange}$APP${reset} /dev/sdX
EOF
	exit 0
}

function sh_setenvironment {
	declare -gA Alocale=([0]=pt_BR [1]=en_US [2]=de_DE [3]=fr_FR [4]=es_ES [5]=it_IT)
	tput sgr0 # reset colors
	bold=$(tput bold)
	reset=$(tput sgr0)
	white="${bold}$(tput setaf 7)"
	black="${bold}$(tput setaf 0)"
	red=$(tput bold)$(tput setaf 196)
	green=$(tput setaf 2)
	yellow=$(tput bold)$(tput setaf 3)
	blue=$(tput setaf 4)
	pink=$(tput setaf 5)
	cyan=$(tput setaf 6)
	orange=$(tput setaf 3)
	purple=$(tput setaf 125);
	violet=$(tput setaf 61);
	COL_NC='\e[0m' # No Color
	COL_LIGHT_GREEN='\e[1;32m'
	COL_LIGHT_RED='\e[1;31m'
	TICK="${white}[${COL_LIGHT_GREEN}✓${COL_NC}${white}]"
	CROSS="${white}[${COL_LIGHT_RED}✗${COL_NC}${white}]"
	INFO="[i]"
	# shellcheck disable=SC2034
	DONE="${COL_LIGHT_GREEN} done!${COL_NC}"
	OVER="\\r\\033[K"
	DOTPREFIX="  ${black}::${reset} "
	sh_set_qemu_common_options
}

function sh_unsetvarcolors {
	unset bold reset cyan red blue white black
	unset green yellow orange pink cyan purple violet
}

function sh_checkDependencies {
	local d
	local errorFound=0
	declare -a missing

	for d in "${DEPENDENCIES[@]}"; do
		[[ -n $(command -v "$d") ]] && { :; } || { \
			printf "%s\n" "${red}ERROR${reset}: Could not find command ${cyan}'$d'${reset} -> install package '${PACKAGEDEP[$d]}'"
			missing+=("$d")
			errorFound=1
		}
	done
	if (( errorFound )); then
		echo "${yellow}---------------IMPOSSIBLE TO CONTINUE---------------"
		echo "${black}This script needs the commands listed above"
		echo "Install them and/or make sure they are in your \$PATH"
		echo "${yellow}---------------IMPOSSIBLE TO CONTINUE---------------"
		exit 1
	fi
}

function filerun_bios {
	if test $# -ge 1; then
		if test -r $1; then
			qemu-system-x86_64\
				-drive file=${1},format=raw,if=none,id=disk1\
				-device ide-hd,drive=disk1,bootindex=1\
		    	-device virtio-scsi-pci,id=scsi0\
				"${qemu_options[@]}"
		else
			log_msg "${red}ERROR: ${cyan}'$1' ${red}could not read or does not exist"
	   fi
   else
		sh_usage
   fi
}

function filerun_uefi {
	if test $# -ge 1; then
		if test -r $1; then
		   local ovmf_code='/usr/share/edk2-ovmf/x64/OVMF_CODE.fd'
			local working_dir="$(mktemp -dt chili-runimage-$USER.XXX)"

			if [[ ! -f '/usr/share/edk2-ovmf/x64/OVMF_VARS.fd' ]]; then
				printf 'ERROR: %s\n' "OVMF_VARS.fd not found. Install edk2-ovmf."
				exit 1
			fi
			cp -av -- '/usr/share/edk2-ovmf/x64/OVMF_VARS.fd' "${working_dir}/"

			if [[ ${1: -4} == ".iso" ]]; then
			  # ISO disk
				qemu-system-x86_64\
				 	-cdrom $1\
				 	-boot d\
	 				-drive if=pflash,format=raw,unit=0,file=${ovmf_code},read-only=off\
					-drive if=pflash,format=raw,unit=1,file=${working_dir}/OVMF_VARS.fd\
					"${qemu_options[@]}"
			else
				# RAW disk
				qemu-system-x86_64\
				  	-drive file=${1},format=raw,if=virtio\
					-drive if=pflash,format=raw,unit=0,file=${ovmf_code},read-only=off\
					-drive if=pflash,format=raw,unit=1,file=${working_dir}/OVMF_VARS.fd\
					"${qemu_options[@]}"
			fi
		else
			log_msg "${red}ERROR: ${cyan}'$1' ${red}could not read or does not exist"
			sh_usage
		fi
	else
		sh_usage
   fi
}

function sh_set_qemu_common_options {
	qemu_options+=(-no-fd-bootchk)
	qemu_options+=(-machine accel=kvm)
	qemu_options+=(-cpu host)
	qemu_options+=(-smp "$(nproc)")
	qemu_options+=(-name 'chili-runimage')
	qemu_options+=(-m ${xmem})
#	qemu_options+=(-vga std)				# ✓ VGA compatible ✓ vgabios support ✓ UEFI support (QemuVideoDxe) ✓ linux driver (bochs-drm.ko)
#	qemu_options+=(-device VGA)
#	qemu_options+=(-device ramfb)			# ✗ not VGA compatible ✓ vgabios support ✓ UEFI support (QemuRamfbDxe)
#	qemu_options+=(-device cirrus-vga)		# ✓ VGA compatible ✓ vgabios support ✓ UEFI support (QemuVideoDxe) ✓ linux driver (cirrus.ko)
#	qemu_options+=(-device qxl)
#	qemu_options+=(-device qxl-vga)
#	qemu_options+=(-vga virtio)				# ✓ VGA compatible ✓ vgabios support ✓ UEFI support (QemuVideoDxe) ✓ linux driver (virtio-gpu.ko)
#	qemu_options+=(-device bochs-display)	# ✗ not VGA compatible	✓ vgabios support ✓ UEFI support (QemuVideoDxe) ✓ linux driver (bochs-drm.ko)
#	qemu_options+=(-vga std)				# ✓ VGA compatible ✓ vgabios support ✓ UEFI support (QemuVideoDxe) ✓ linux driver (bochs-drm.ko)
#	qemu_options+=(-device qxl-vga)
#	qemu_options+=(-device ati-vga)
	qemu_options+=(-vga qxl) 				# ✓ VGA compatible ✓ vgabios support ✓ UEFI support (QemuVideoDxe) ✓ linux driver (qxl.ko) ✓ windows driver
	qemu_options+=(-display gtk)
	qemu_options+=(-device intel-hda)
	qemu_options+=(-audiodev pa,id=snd0,server=localhost)
	qemu_options+=(-device hda-output,audiodev=snd0)
	qemu_options+=(-device ich9-intel-hda)
	qemu_options+=(-global ICH9-LPC.disable_s3=1)
	qemu_options+=(-machine type=q35,smm=on,accel=kvm,usb=on,pcspk-audiodev=snd0)
	qemu_options+=(-serial stdio)
}

#				  	-netdev user,id=net0 \
#				  	-device virtio-net-pci,netdev=net0 \
#				  	-net nic,model=virtio \
#				  	-net user \

sh_setenvironment
sh_checkDependencies

OPTIONS=ubVnh
LONGOPTIONS=uefi,bridge,version,nocolor,help
opts=$(getopt --options=$OPTIONS --longoptions=$LONGOPTIONS --name "$0" -- "$@")
if [ $? -ne 0 ]; then
	sh_usage
fi
eval set -- "$opts"

while true; do
	case "$1" in
		-u|--uefi)  	uefi=1;shift;;
		-b|--bridge)  	bridge=1;shift;;
		-n|--nocolor)  sh_unsetvarcolors;shift;;
		-V|--version)  sh_version;;
		-h|--help)     sh_usage;;
		--)            shift;break;;
		*)             sh_usage;;
	esac
done

sh_checkRoot
if ((bridge)); then
	random_mac=$(python3 -c "import random; print(':'.join(['{:02x}'.format(random.randint(0, 255)) for _ in range(6)]))")
	qemu_options+=(-netdev bridge,br=$iface_bridge,id=net0)
	qemu_options+=(-device e1000,netdev=net0,mac=$random_mac)
else
	qemu_options+=(-netdev user,id=net0)
	qemu_options+=(-device e1000,netdev=net0)
fi
if ((uefi)); then
	filerun_uefi "$@"
else
	filerun_bios "$@"
fi
